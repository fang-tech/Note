# 深入理解JVM中的垃圾回收机制

## 判断一个对象是否可以被回收

### 引用计数法

给对象添加一个引用计数器, 当对象增加一个引用的时候计数器加1, 引用失效的时候计数器减1, 当计数器等于0的时候该对象可回收

但是这个方法无法解决两个对象循环引用的情况, 这种情况两个对象的引用计数器永远不为0

也正是这个致命的原因, Java不使用引用计数法

### 可达性分析算法

从GC Roots为起始点进行搜索, 能够达到的对象都是存活的, 不可达的对象回收, 更具体地说, GC Roots实际上是现在可用的需要用的引用的集合, 通过这些引用我们就能达到我们目前需要使用的所有对象, 从而判定出来不可达的对象就是不可用的, 需要回收的

GC Roots一般包含以下内容

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象

## 引用类型

### 强引用

被强引用关联的对象不会被回收

使用new一个新对象的方式创建强引用

```java
Object obj = new Object();
```

### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收

使用`SoftReference`类来创建软引用

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
```



### 弱引用

被弱引用关联的对象, 会在下一次垃圾回收的时候被回收

使用`WeakReference`来创建弱引用

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### 虚引用

和对象被回收的时机无关, 被虚引用关联的对象唯一的特殊点就是被回收的时候会收到一个系统通知

通过`PhantomReference`

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 垃圾回收算法

### 1. 标记- 清除

![image](https://pdai.tech/images/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg)

将存活的对象标记, 清理掉没有被标记的对象

不足

- 标记和清除的效率不高
- 会产生大量的不连续内存碎片

### 2. 标记 - 整理

![image](https://pdai.tech/images/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg)

让所有存活的对象都向一端移动, 清除掉端边界外以外的内存

### 3. 复制

![image](https://pdai.tech/images/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg)

将内存划分成两块, 每次只使用其中一块, 当这一块用完了, 就将这块上还存活的对象复制到另一块上, 对这一块进行清理

现代虚拟机都通过这种方法来回收新生代

### 4. 分代收集

根据对象存活周期将内存划分成几块, 不同块采用不同的收集算法

- 新生代 : 复制算法
- 老年底 : 标记-清除或标记整理算法

## 垃圾收集器

单线程与多线程 : 垃圾处理器只使用一个线程还是多个线程垃圾收集

串行和并行 : 垃圾收集程序会阻塞用户程序, 并行指垃圾收集程序和用户程序同时执行

### 1. Serial收集器

串行单线程的收集器, 拥有最高的单线程收集效率

是Client模式下的默认新生代垃圾收集器, 因为用户桌面应用场景下, 分配给虚拟机管理的内存一般不是很大, 而Serial收集器在收集小内存(几十兆或一两百兆)时候的表现很不错, 可以将阻塞时间控制在100多毫秒以内

### 2. ParNew收集器

Serial收集器的多线程版本

Server模式下的虚拟机首选的新生代收集器, 除了性能原因主要是除了Serial只有它能和CMS收集器配合工作

默认开启的线程数量与CPU数量相同, 可以使用`-XX:ParallelGCThreads`参数来设置线程数

### 3. Parallel Scavenge收集器

多线程收集器

比起其他收集器关注缩短垃圾收集的时候用户线程阻塞的时间, 它的目标是达到一个可控制的吞吐量, 吞吐量优先收集器(CPU运行用于代码时间/总时间)

阻塞时间越短越适合需要和用户交互的程序, 高吞吐量则可以高效利用CPU时间, 尽快完成程序, 适合在后台运算不需要太多交互的任务

缩短停顿时间是以牺牲吞吐量和新生代空间换取的, 新生代空间变小, 垃圾回收变频繁, 吞吐量下降

### 4. Serial Old收集器

Serial收集器的老年代版本, 也是给Client模式下的虚拟机使用, 如果是在Server模式下, 它有两个用途

- 作为CMS收集器的后备预案, 在并发收集产生Concurrent Mode Failure时使用
- 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用

### 5. Parallel Old 收集器

Parallel Scavenge收集器的老年代版本, 注重吞吐量和CPU资源敏感的场合, 都可以优先考虑Parallel Scvenge + Parallel Old收集器

### 6. CMS收集器

(Concurrent Mark Sweep), Mark Sweep指的是标记 - 清除算法

- 初始标记: 仅仅是标记一下GC Roots能够直接关联的对象, 速度很快, 需要停顿
- 并发标记: 进行GC Roots Tracing的过程, 在整个回收过程中耗时最长, 不需要停顿
- 重发标记: 为了修正并发标记期间因为用户程序继续运行导致的标记产生了变动的那一部分对象的标记, 需要停顿
- 并发清除: 不需要停顿

缺点

- 吞吐量低: 低停顿时间的代价就是低吞吐量
- 无法处理浮动垃圾: 浮动垃圾指的是并发清除阶段, 因为用户线程继续运行而产生的垃圾, 这些垃圾只能下一次GC的时候才能回收, 因为浮动垃圾的存在, 因此需要预留一部分内存, 而不是像其他的收集器那样等待老年代快满了再回收. 如果预留的内存不够存放浮动垃圾, 就会出现Concurrent Mode Failure 这个时候就会启动Serial Old来代替CMS
- 空间碎片导致无法找到足够大的连续空间分配大对象, 不得不提前触发一次Full GC

### 7. G1收集器

一款面向服务端的垃圾收集器

G1收集器将堆分成多个大小相等的独立区域, 新生代和老年代不再隔离

每个小空间单独进行垃圾回收, 通过这个区域概念, 使得可预测的停顿时间模型成为可能. 通过记录每个区域垃圾回收时间和所获得的空间, 并维护一个优先列表, 每次根据允许的收集时间, 优先回收价值最大的区域

 每个区域都有一个Remembered Set, 用来记录这个区域对象的引用对象所在的区域, 从而实现了局部可达性分析, 在做可达性分析的时候不再需要全堆扫描

G1收集器运作大致分成

1. 初始标记
2. 并发标记
3. 最终标记 :  为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. 筛选回收 : 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率

优点

- 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

- 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

## 内存分配和回收策略

### Minor GC, Major GC, Full GC

- 部分收集: 不是完整收集整个Java堆的垃圾收集
  - 新生代收集 (Minor GC/ Young GC): 只是新生代的垃圾收集
  - 老年代收集 (Major GC/Old GC): 只是新生代的垃圾收集
    - 只有CMS GC有单独收集老年代的行为
    - 很多时候Major GC会和Full GC混用
- 混合收集 (Mixed GC): 收集整个新生代和部分老年代
  - 只有G1
- 整堆收集 : 收集整个Java堆和方法区的垃圾

### 空间分配担保

**在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

### Full GC的触发条件

1. 调用System.gc(), 建议虚拟机执行Full GC, 但是不一定会执行
2. 老年代空间不足 : 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
3. Concurrent Mode Failure : 会触发Full GC
4. 空间分配担保失败