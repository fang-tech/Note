# JVM的类加载机制

## JVM怎么识别出来是class格式的文件

```hex
00000000: cafe babe 0000 0034 0022 0700 0201 0019  .......4."......
00000010: 636f 6d2f 636d 6f77 6572 2f6a 6176 615f  com/cmower/java_
00000020: 6465 6d6f 2f54 6573 7407 0004 0100 106a  demo/Test......j
00000030: 6176 612f 6c61 6e67 2f4f 626a 6563 7401  ava/lang/Object.
00000040: 0006 3c69 6e69 743e 0100 0328 2956 0100  ..<init>...()V..
00000050: 0443 6f64 650a 0003 0009 0c00 0500 0601  .Code...........
00000060: 000f 4c69 6e65 4e75 6d62 6572 5461 626c  ..LineNumberTabl
```

这是一个class文件在十六进制的内容, 前两个字节`cafe babe`就是著名的"魔数", 是JVM识别.class文件的标志(.class只是为了方便给人识别的后缀, 对于程序来说是没有意义的)

## 类记载机制

类从被加载到JVM, 到卸载出内存, 整个生命周期共有七步

加载, 验证, 准备, 解析, 初始化, 使用, 卸载

其中 验证, 准备, 解析 三个步骤统称为连接, 前五个步骤就是JVM的类加载过程

### 1. Loading(载入)

该阶段将字节码从不同的数据源中(.class文件, jar包...)转化成二进制字节流加载进内存中, 并生成一个代表该类的`java.lang.Class`对象

### 2. Vertification (验证)

JVM在该阶段会对二进制字节流进行校验, 只有符合JVM字节码规范的才能被JVM正确执行

- 确保二进制字节流符合预期(比如以cafe babe开头)
- 是否所有的方法都遵循访问控制关键字的限定
- 方法调用的参数个数和类型是否正确
- 确保变量在使用之前被正确初始化了
- 检查变量是否被赋予恰当类型的值
- ...

### 3. Preparation (准备)

这个阶段JVM会对类变量(也就是static修饰的变量)分配内存并初始化, 对应数据类型的默认初始值

```java
public String str1 = "asd";
public static String str2 = "adada";
public static final String str3 = "asdf";
```

- str1变量不会被分配内存, 因为不是类变量
- str2会被分配内存, 但是值是null
- str3会被分配内存, 同时值是"asdf"

static final修饰的变量是常量, 会在准备阶段就赋值

### 4. Resolution (解析)

该阶段将常量池中的符号引用转化成直接引用

符号引用

- 是类, 字段, 方法, 接口等的全限定名, 比如`com.func.Person`
- 在编译阶段生成, 存储在编译后的字节码文件的常量池中
- 不依赖于具体的内存地址

直接引用

- 直接指向目标的指针, 相对偏移量或者能间接定位到目标的句柄
- 在运行的时候JVM的解析阶段生成, 也可以是在运行阶段需要使用这个引用的时候生成
- 依赖于JVM的具体内存布局, 直接指向了内存地址或者偏移量

不发生动态加载的情况下, 在编译完毕以后, 实际上代码中的引用是会被翻译成符号引用的, 用于唯一索引到对应的类, 接口, 字段, 方法上, 然后在JVM类加载过程中的解析步骤, JVM会将符号引用替换成指向内存中的实例对象的直接引用, 同时因为是静态加载, 就能将一个符号解析的结果缓存起来

如果有动态加载, 会在需要使用这个引用的时候将符号引用加载成直接引用, 指向内存中的class或者其元数据

解析阶段解析的内容有

- 对类和接口的解析
- 对类方法的解析
- 接口方法的解析
- 字段解析

### 5. Initialization (初始化)

在准备阶段, 赋予的值是类型默认值, 在这个阶段会完成为变量赋值代码期望赋予的值, 在初始化阶段执行类构造器方法

初始化的时机有

- 创建类实例的时候
- 访问类的静态方法或静态字段的时候(除了final常量, 因为它们在编译阶段就被放进了常量池)
- 使用java.lang.reflect包的方法对类进行反射调用的时候
- 初始化一个类的子类(首先会初始化父类)
- JVM启动的时候, MAIN方法类会被初始化

## 类加载器

JVM通过类加载器和这个类本身一同确定其唯一性, 也就是如果两个类来自于同一个字节码, 但是是通过不同的类加载器加载出来的, 不是同一个类

类加载器分成四种

1. 引导类加载器 (Bootstrap ClassLoader) : 负责JVM基础核心类库, 比如rt.jar, sum.bott.class.path路径下的类
2. 扩展类加载器 (Extension ClassLoader) : 负责加载Java扩展库中的类, 比如jre/lib/ext目录下的类或者有系统属性java.ext.dirs指定位置的类(ClassLoader的类名是PlatformClassLoader)
3. 系统(应用)类加载器 (System ClassLoader) : 负责加载系统类路径 java.class.path指定的类库, 通常是应用类或者第三方类库(ClassLoader的类名是AppClassLoader)
4. 用户自定义的类加载器, 通过继承java.lang.ClassLoader来实现

## 双亲委派模型

简单来说就是, 类加载器在加载一个类的时候, 会首先尝试将这个类委派给自己的父加载器去加载, 只有在父加载器无法加载此类的时候, 子加载器才会尝试自己的加载, 同时这个委派过程是递归的, 也就是如果我们要使用应用类加载器去加载一个类, 最后会递归到引导类加载器加载

这种机制能确保不会重复加载类, 同时保证了类加载器之间的优先级关系, 保护了Java核心API不会被恶意替换