# JVM运行时数据区

## 程序计数器

每个线程都有自己的**私有**的PC(Program Counter), 

**线程执行的是非本地方法, PC指向下一条将要运行的指令**(准确来说是, 在执行指令的时候, PC指向下一条将要运行的指令, 在其他任意时刻, 指向的是下一条要运行的指令)

**线程执行的是本地方法的时候, PC的值是undefined**, 因为本地方法不是在JVM中运行的, 往往是通过C/C++实现

## 虚拟机栈

这个在深入理解栈帧里面有详细说明

## 本地方法栈

区别于虚拟机栈, 本地方法栈为虚拟机使用到的本地方法服务

## 堆

**堆区是所有线程共享的一块区域, 用来存储对象**

Java中的几乎所有对象都是在堆中存储的

> 为什么不是所有?

现代JVM默认开启逃逸分析, 如果某些方法中的对象或者引用没有在方法之外被使用过(也就是没有逃逸), 这个时候就会将对象存储在虚拟机栈中的局部变量空间

堆区最容易出现的错误就是OOM(Out of Memory), 有两种表现形式

- `OutOfMemoryError : GC Overhead Limit Exceed`: 当JVM花太长时间执行垃圾回收还没有回收到多少内存的时候就会发生
- `java.lang.OutOfMemoryError: Java heap space`: 堆中的空间不足够申请的新的对象, 和配置的虚拟机的堆内存有关

## 方法区(永久代/元空间)

永久代和元空间都是对于方法区的一个实现

永久代是在JVM内存中的, 元空间直接使用的是操作系统的内存而不是JVM内存

在元空间数据增长的时候, 会从操作系统申请内存, 也就是在这一步, 元空间增长也会导致操作系统层面的OOM

### 运行时常量池

.class文件中有常量池, 在运行的时候, 将class文件中的常量池加载到内存中

### 字符串常量池

在堆区中, 在jdk1.6的时候在永久代中, 从1.7开始就被迁移到了堆区