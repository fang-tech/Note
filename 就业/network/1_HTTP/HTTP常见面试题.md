# HTTP常见面试题目

## HTTP基本概念

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

### HTTP常见的状态码有哪些

`1xx`类状态码属于**提示信息**, 基本遇不到

`2xx`类状态码表示服务器**成功处理**了客户端的请求

- \[**200 OK**] 是最常见的成功状态码, 表示一切正常, 非HEAD请求, 服务器返回的响应头都会有body数据
- [**204 No Content**] 也是最常见的状态码, 和200 OK的区别是响应头没有数据
- [**206 Partial Content**] 应用于HTTP分块下载或断点续传, 表示响应返回的body不是资源的全部, 而是其中的一部分

`3xx`类状态码表示客户端请求的资源发生了变动, 需要客户端**重定向**

- [**301 Moved Permanently**] 永久重定向, 请求的资源已经不存在, 浏览器会自动重定向到新的服务器
- [**302 Found**] 临时重定向, 请求的资源还在, 但是需要用另一个URL来 访问

301和302都会在响应头里面使用字段`Location`来指明接下来要跳转到的URL地址

- [**304 Not Modified**] 不具有跳转的含义, 表示资源未修改, 重定向已存在的缓存文件, 告诉客户端继续使用缓存文件, 用于缓存控制

`4xx`类状态码表示客户端发送的**报文有误**, 服务器无法处理

- [**400 Bad Request**] 请求报文有问题
- [**403 Forbidden**] 客户端访问禁止访问的资源
- [**404 Not Found**] 请求的资源不在服务器上

`5xx`类状态码表示请求报文正确, 但是服务器内部处理错误, 是服务器的错误码

- [**500 Internal Server Error**] 和400一样是个通用笼统的错误码
- [**501 Not Implemented**] 客户端请求的功能还不支持
- [**502 Bad Gateway**] 是服务器作为网关或者代理的时候返回的错误码,  访问后端服务的时候出错
- [**503 Service Unavailable**] 服务器当前很忙, 暂时无法响应客户端

### HTTP常见字段有哪些

- Host :  `Host: www.A.com` 指定访问的域名
- Content-Length : `Content-Length: 1000` 本次回应的长度, 因为使用TCP作为传输协议, 会有粘包的问题, **HTTP协议通过设置回车符, 换行符作为HTTP header的边界, 通过Content-Length来作为HTTP body的边界**

- Connection : `Connection : Keep-Alive` 客户端要求服务器使用HTTP长连接机制, 以便其他请求复用, 连接会一直持续到客户端或服务器提出断开连接
- Content-Type : `Content-Type: text/html; Charset=utf-8` 用于服务器回应时, 告诉客户端本次数据的格式
  - Accept :`Accept: */*` 客户端请求的时候, 可以通过Accept字段声明自己可以接受的数据格式
- Content-Encoding : `Content-Encoding: gzip` 说明数据压缩的发放, 表示服务器返回的数据采用了什么压缩格式
  - Accept-Encoding : `Accept-Encoding: gzip, deflate`, 客户端请求的时候, 用这个字段说明自己可以接受哪些压缩方法

## GET和POST

### GET和POST有什么区别

根据RFC规范

- GET的语义是从服务器获取指定的资源, 	GET请求的参数一般是放在URL中的, URL必须以ASCII编码, 所以GET请求的参数只有ASCII字符, 同时浏览器会对URL的长度做出限制
- POST的语义是根据请求负荷对指定的资源做出处理, 浏览器不会对请求体做出限制

### GET和POST方法都是安全且幂等的吗

在RFC规范语义下, 显而易见的是GET是安全且幂等的,  因为GET请求是只读操作. 所以可以对GET请求的数据做出缓存, 缓存可以放在浏览器上, 也可以放在代理上. 同时在浏览器中GET请求可以保存为书签

但是实际开发过程中, 并不一定会遵守RFC规范, 如果GET方法执行了写操作, 就不会是安全且幂等的

## HTTP缓存

### 强制缓存

浏览器将数据缓存在本地, 强制缓存是**由浏览器来决定是否使用缓存**

通过以下两个HTTP响应头部的字段实现

- Cache-Control : 相对过期时间
- Expires : 绝对过期时间

Cache-Control的优先级高于Expires

- 当服务器第一次请求资源的时候, 服务器会在返回资源的时候同时在响应头部中Cache-Control字段中说明资源的相对过期时间
- 浏览器再次请求相同的数据的时候, 就会先将请求资源的时间和Cache-Control中设置的相对过期时间大小来计算出来资源是否过期
  - 过期了重新请求服务器, 并再次更新Cache-Control
  - 没有过期则直接使用缓存中的数据

### 协商缓存

协商缓存就是在强制缓存失败了以后, 和服务器协商是不是真的要不使用缓存, **也就是协商缓存一定要先开启强制缓存, 只有在未命中强制缓存的时候, 才会走协商缓存**

通过两种头部字段来实现

第一种: 请求头中的`If-Modified-Since`字段和响应头中的`Last-Modified`字段实现

- 响应头中的Last-Modified : 这个响应资源的最后修改时间
- 请求头中的If-Modified-Since : 强制缓存过期了以后发现当时的响应头中有Last-Modified声明, 则再次发起请求的时候会携带上If-Modified-Since(这个时候的值就是响应头中的Last-Modified中的值)
  - 如果最后修改时间大于If-Modified-Since中的值, 说明缓存中资源已经被修改过了, 这个时候就会返回资源, 状态码200 OK
  - 如果最后修改时间小于等于 If-Modified-Since中的值, 说明缓存中值没有被修改过, 就能继续使用, 返回304 Not Modified, 继续使用缓存中的资源

第二种: 请求头中的`If-None-Match`和响应头中的`ETag`字段

- 响应头中的ETag: 唯一标识响应资源
- 请求头中的`If-None-Match`: 当资源过期的时候, 浏览器发现当时的响应头中有ETag字段, 就会在If-None-Match子段中携带上当时ETag中的值, 向服务器发起请求, 服务器收到了以后进行比对
  - 如果相同, 说明资源没有被修改过, 返回304
  - 如果不同, 返回资源, 200

**ETag的优先级高于Last-Modified, 如果服务端返回的响应头部中两个字段都有, 在下次过期的时候, 会优先比对ETag, 如果ETag已经有变化了, 就不会比对Last-Modified了**

> 为什么ETag的优先级更高?

1. 没有修改文件内容的前提下, 文件最后修改时间也可能会变(比如修改了文件的权限等)
2. 有些文件的修改是在秒级以内的, Last-Modified的粒度是秒级的
3. 有些服务器无法精确获取到文件的最后修改时间

## HTTP特性

### HTTP/1.1的缺点在哪里

1. **无状态** : 常见的解决方法有Cookie技术, Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态
2. 明文传输 : 信息裸奔
3. 不安全 : 
   - 通信使用明文
   - 不验证通信方的身份
   - 无法证明报文的完整性

### HTTP/1.1的性能如何

从HTTP/1.1是基于TCP/IP, 并且使用了 [请求-应答] 的通信模式出发

1. 长连接 : 能够复用TCP连接
2. 管道网络传输 : 流水线式发送请求, 发送了第一个请求以后, 不需要等待第一个请求的响应, 可以直接发送第二个请求, **服务器必须按照接收请求的顺序发送对这些管道化请求的响应**, **管道解决了请求的队头堵塞, 但是没有解决响应的队头堵塞**

3. 队头堵塞 : 请求-应答的通信模式中, 如果某一个请求因为某种原因被阻塞了, 一直没有收到回应, 就会一直阻塞下去, 这个时候后面排队的请求也都一同被阻塞了

## HTTP和HTTPS

### HTTP和HTTPS简单的区别

- HTTP是明文传输, HTTPS在TCP和HTTP网络层之间加入了SSL/TLS安全协议, 使得报文能够密文传输
- HTTPS建立连接的过程除了TCP的三次握手, 还需要SSL/TLS的握手过程, 才能进行密文的传输
- HTTP的默认端口是80, HTTPS的默认端口是443
- HTTPS需要向CA申请数字证书

### HTTPS解决了HTTP的哪些问题

- 窃听风险 : 可以从通信链路上获取通信数据
- 篡改风险 : 强制植入广告等, 能修改HTTP传输的数据
- 冒充风险 : 冒充淘宝网站等

解决方案 : SSL/TLS协议

- 信息加密 : 不再是明文传输
- 校验机制 : 校验通信的内容, 防止篡改通信的内容
- 身份验证 : 验证网站是真的网站

怎么实现的这三点 ?

- **混合加密**的方式实现信息的加密
- **摘要算法**实现了完整性, 会为数据生成数据指纹
- 将服务器公钥放入到**数字证书**中, 解决了冒充的风险

#### 1. 混合加密

**对称加密** : 双方使用相同的密钥进行加密解密, 加密解密速度快

**非对称加密** : 使用一队密钥(公钥和私钥), 一个用于加密数据, 一个用于解密数据, 安全性更好, 但是速度更慢

HTTPS采用**混合加密**

- 通信建立前采用**非对称加密**的方式交换会话密钥, 后续不再使用非对称加密
- 通信过程中全部使用**对称加密**的会话密钥加密明文数据

#### 2. 摘要算法 + 数字签名

为了保证数据不被篡改, 计算机会为传输的内容通过**摘要算法来计算内容的哈希值**

**通过哈希算法能保证内容不会被篡改, 但是没办法保证\[内容 + 哈希值]不会收到篡改, 缺少对客户端收到的消息来源于服务端的证明**

通过**非对称加密算法**来解决这个问题

在非对称加密算法里面

- **公钥加密, 私钥解密** : 保证**消息传输安全**, 公钥加密的内容别人是无法解密的, 只有私钥的持有者能够解密
- **私钥加密, 公钥解密** : 保证**消息不会被冒充**, 如果这个内容公钥能够解密, 说明就是私钥持有者发送过来的

HTTPS通过**私钥加密, 公钥解密来确认消息的身份**, 也就是**数字签名算法**, **对内容的哈希值加密**

#### 3. 数字证书

- 使用摘要算法保证消息不会被篡改
- 使用数字签名算法保证消息来源的可靠性

但是如果我们伪造一对公私钥, 将客户端的公钥替换成自己伪造的公钥, 这样就能使用自己的私钥发送消息了

解决办法是引入权威机构来保证公钥的正确性

- 服务器将自己的公钥注册到CA
- CA用自己的私钥将服务器的公钥数字签名(加密)并颁发数字证书(信息 + 公钥 + 数字签名)
- 客户端拿到服务器的数字证书以后, 使用CA的公钥确认服务器的数字证书的真实性
- 之后, 从数字证书获取服务器公钥以后, 使用它对报文加密发送

能够信任证书的原因在于**我们能够确信, 能够通过浏览器或者操作系统内置的, 可信的CA公钥揭秘出来的签名只能是由CA私钥加密的, 并且CA公钥无法被未经授权的方式替换或伪造 **

### HTTPS是如何建立连接的? 其间交互了什么

SSL/TLS协议的基本流程是

- 客户端向服务器索要并验证服务器的公钥
- 双方协商生产 \[会话密钥]
- 双方使用会话密钥进行加密通讯

TLS的握手阶段设计**四次通信**, 不同的密钥交换算法握手的流程是不一样的, 常用的有RSA算法和ECDHE算法, 后面讲解的是RSA算法

TLS协议建立的详细过程

*1.ClientHello*

客户端向服务端发起加密通信请求, 主要发送了以下的信息

1. 客户端支持的TLS版本
2. 客户端生成的随机数(`Client Random`), 是后面用于生成会话密钥的条件之一
3. 客户端支持的密码套件列表, 比如RSA加密算法

*2. ServerHello*

服务端响应客户端的加密通信请求

1. 确认TLS的版本, 如果客户端支持的TLS版本服务端都不支持, 就会关闭加密通信
2. 服务端生成的随机数(`Server Random`), 也是后面生产会话密钥的条件之一
3. 确认密钥套件
4. 服务器的数字证书

*3. 客户端回应*

客户端收到服务器的回应以后

首先, 通过浏览器或者操作系统中的CA公钥对数字证书解密获取其中服务器的公钥, 使用服务器的公钥加密报文, 加密的内容如下

1. 一个随机数(`pre-master key`), 是后面生产会话密钥的条件之一
2. 加密通信算法改变通知, 表示随后的信息都将会使用会话密钥加密通信
3. 客户端握手结束通知, 这一项同时把之前所有内容发送的数据做了摘要供服务端校验

**客户端和服务端在客户端回应以后都拥有了三个相同的随机数(`ClientRandom, ServerRandom, pre-master key`), 通过这三个随机数和两边协商出来的密钥套件, 各自计算出来这次通信的会话密钥**

*4.服务端回应*

服务端计算出来这次通信的会话密钥以后, 随后向服务端发送最后的信息

1. 加密算法改变通知, 表示随后的信息都将会使用会话密钥加密通信
2. 服务端握手结束通知, 表示服务端的握手阶段已经结束了, 这一项同时把之前所有内容发送的数据都做了摘要供客户端校验

这样以后, TLS握手阶段技术, 这之后就是正常的HTTP通信, 只不过内容是使用会话密钥加密以后的内容

> RSA算法的缺陷

基于RSA算法的HTTPS有**前向安全**的问题, 如果服务端的私钥泄露了, 过去被第三方截获的所有的TLS通讯密文都会被破解

> 客户端校验数字证书的流程是怎么样的

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png)

CA签发证书的过程可以分成以下的步骤

1. 将持有者的公钥, 用途, 颁发者, 有效时间信息等打包成一个包, 然后通过hash算法生成一个hash value
2. 再通过CA私钥对hash Value进行加密, 生成Certificate Signature
3. 然后将hash值和前面的信息包组成一个数字证书

客户端校验的过程如下

1. 通过浏览器或者操作系统内置的CA公钥, 解密Certificate Signature, 得到H1
2. 然后通过和CA相同的Hash算法计算上面的信息包, 得到H2
3. 将H1和H2比对, 如果相同, 说明是可信赖的证书

### HTTPS的应用数据是怎么保证完整性的

TLS在实现上分成了**握手协议**和记录协议两部分

- **握手协议就是四次握手怎么双方验证身份, 生成会话密钥的过程**
- **记录协议就是怎么使用会话密钥加密HTTP的内容的过程**

TLS记录协议主要负责消息的**压缩**, **加密**, **数据的认证**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/计算机网络/HTTP/记录协议.png)

具体的过程如下

1. 将消息分割成多个较短的片段, 然后对每个片段进行压缩
2. 对每个压缩过的片段加上Hash算法计算出来的消息认证码(MAC值), 以此保证消息不会被篡改. 同时为了防止重放攻击, 还在计算消息认证码的时候, 加上了片段的编码(一个独特的编号, 防止攻击者发送之前已经发送过的旧的数据包, 来重复操作)
3. 然后将压缩过的片段加上消息认证码一起使用对称密码加密
4. 为加密后的数据添加上数据类型, 版本号, 压缩后的长度组成的报文就是最终的报文数据

## HTTP/2对比HTTP/1.1做了哪些改进

- 头部压缩
- 二进制格式
- 并发传输
- 服务器主动推送资源

#### 1. 头部压缩

HTTP/2 会压缩头, 如果你同时发出多个请求, 头部是相似的或者一样的, 协议会帮你消除重复的头部

使用的HPACK算法 : 客户端和服务器同时维护一张头信息表, 所有的字段都会存入到这张表中, 生成一个索引号, 只发送索引号就行了

静态表：想象这是一本字典，里面预先定义了最常用的 HTTP 头部字段。比如 "method: GET" 可能是字典中的第 2 号词条。这样，当我们需要发送 "method: GET" 时，只需发送数字 2 即可，接收方查字典就知道是什么意思了。
动态表：这是一个在通信过程中不断更新的字典。如果发送了一个新的头部字段，它会被添加到动态表中。下次再发送相同的头部时，只需引用它在表中的索引即可。
霍夫曼编码：对于无法通过表查找的值，HPACK 使用霍夫曼编码进一步压缩。霍夫曼编码是一种根据字符出现频率分配短代码的方法，常用字符获得短编码，不常用字符获得长编码。

举个例子
假设我们要发送这样的 HTTP 头部：
:method: GET
:path: /index.html
user-agent: Mozilla/5.0
cookie: session=abc123
第一次发送时，HPACK 会：

:method: GET 在静态表中找到，发送索引号
:path: /index.html 的键在静态表中找到，但值需要霍夫曼编码发送
user-agent: Mozilla/5.0 的键在静态表中找到，值用霍夫曼编码发送，然后添加到动态表
cookie: session=abc123 也类似处理，添加到动态表

第二次发送类似的请求时，可能就能直接通过静态表和动态表的索引号引用大部分头部字段，大大减少传输数据量。

#### 2. 二进制格式

传输的内容直接变成了二进制, 这样接收端就不需要再转化了

#### 3. 并发传输

将一个TCP连接进一步细化, 分成多个STREAM, 内部以frame作为STREAM中传输的最小单位, 以二进制压缩格式存放HTTP/1中的内容

不同的HTTP请求用独一无二的STREAM ID来区分, 接收端可以根据Stream ID有序组装成HTTP消息, 不同Stream的帧是可以乱序发送的

假设我们现在有两个HTTP请求, 在原本的模型, 我们只能发送请求A, 等待请求A响应, 发送请求B, 等待请求B响应

但是有了Stream机制以后, 我们能将请求A分配给Stream1, 请求B分配给Stream3, 两个请求同时发送

然后接收端将ID都是1的frame组装成一个完整的请求, 将ID都是3的组装成另一个

#### 4. 服务器推送

在HTTP/2中, 服务端也能主动向客户端发送消息

服务端和接收端能双向建立Stream通道, 然后相互发消息, 服务端建立的Stream必须是偶数号, 服务端建立的Stream必须是偶数号

**HTTP/2还是因为TCP的必须保证收到的字节数据是完整且连续的, 所有还是有队头堵塞, 会因为TCP中的某个包而堵塞住**

## 如何优化HTTP/1.1

从三点出发

- 尽量避免发送HTTP请求
  - 使用缓存, 浏览器中的缓存是将第一次请求以及响应的数据保存在磁盘上, URL作为Key, 响应作为Value
  - 缓存有强制缓存和协商缓存
- 减少HTTP请求的次数
  - 减少重定向请求的次数
    - 重定向的工作交给代理服务器完成
    - 原本是客户端 -> 代理服务器 -> 源服务器 : 302 Found, Location: url2, 然后在重新客户端 -> 代理服务器 -> 源服务器不过url是url2
    - 将重定向的工作交给代理服务器以后, 客户端 -> 代理服务器 -> 源服务器 : 302 Found, Location: url2, 代理 服务器 -> 源服务器 url是url2, 访问到资源以后, 响应客户端->代理服务器的请求, 将资源返回, 减少了消息传递的次数
  - 合并请求
    - 将多个访问小文件的请求合并成一个大的请求, 减少了请求的次数, 减少了重复发送的HTTP头部
    - 另外由于HTTP/1.1是请求响应模型 , 为了防止队头堵塞, 浏览器发送请求一般都是同时发送5-6个请求, 走不同的TCP连接, 合并了请求也能减少TCP握手和慢启动的时间
    - 合并请求的方式就是合并资源, 以一个大的资源的请求替换多个小的资源的请求. 但是也会带来在请求失败或者资源需要更新的时候, 客户端需要重新下载整个大的资源
  - 按需获取
    - 需要用到的时候才去尝试获取资源, 来减少第一时间发送的HTTP请求
- 减少HTTP 响应的数据大小
  - 无损压缩 : gzip, Brotli等, 一般用于发送文本文件, 程序可执行文件等不能有损的文件内容
  - 有损压缩 : WebP(图片), H264, H265等, 一般用于音视频和图片内容

## 有了HTTP为什么还要有RPC

### 应该是有了RPC为什么还要有HTTP

RPC(Remote Procedure Call), 远程过程调用, 可以理解为一种对于能直接调用远程的方法的一种调用方式, 可以说是指的一类协议 : 让我们能够像调用本地方法一样调用远端服务器暴露出来的一个方法, 同时屏蔽掉一些网络的细节

RPC早于HTTP, 早年的时候各个公司自己的客户端和服务端之间通信使用的都是自己造的RPC协议, 但是到了后面,  出现了浏览器, 不光要能访问自家的服务器还要能访问其他公司的服务器, 这个时候就需要一个统一的协议, 就是HTTP

### HTTP和RPC有什么区别

#### 服务发现

发现服务对应的IP:port就是服务发现

在HTTP中往往是知道域名, 由DNS解析得到后面的IP地址, 默认80端口

RPC一般有专门的中间服务来保存服务名和IP信息, 像Consul, Etcd, Redis

#### 底层连接形式

RPC能多个连接池, 维护多个长TCP连接, 就和数据库的连接池一样, 减少建立连接和销毁连接的开销

#### 传输的内容

基于TCP传输的消息, 都是由消息头和消息体两部分组成

- 消息头中最重要的是长度信息
- Body中存储的内容可以二进制, 数字等都可以

这里也是最大的区别, HTTP中有很多是针对于浏览器设置的内容, 比如302状态码等内容, 但是RPC不用, RPC定制化成都更高, 能够使用体积更小的Protobuf或其他序列化协议去保存结构体数据

## 既然有了HTTP协议, 为什么还要有WebSocket?

WebSocket是为了解决服务器主动向客户端发送信息这个通信场景

### 使用HTTP协议怎么实现服务器主动向客户端发送消息

#### 定时轮询

客户端每隔一段时间就向服务端发送请求, 看服务端是不是想发送信息给客户端了

这样的实现其实是伪服务器发送信息给客户端

这个实现的缺点

- 服务器想发送数据给客户端有延时, 最极端的情况, 需要等待完整的一个时间间隔才能将数据发送到客户端
- 频繁的空请求加重服务器的负担

#### 长轮询

HTTP请求是\[请求-应答]模式, 在这种模式下, 请求方会阻塞等待响应方给出响应, 我们通过这个模式就能实现一有消息就通知给客户端, 我们设置很长的响应时间, 如果超时了就重新发送请求.

在等待响应的过程中, 一有消息, 就能成功接受到, 但是这个也就只能适用于扫码等简单的交互场景, 如果有大量的数据需要从服务端主动推送给客户端, 那么就需要使用WebSocket

### WebSocket

TCP连接的双端, 同一时间内, 其实双方都能相互主动发送消息, 这就是**全双工**

而HTTP/1.1, 同一时间内, 只能有一方能主动发送消息, 这就是**半双工**

#### 怎么建立WebSocket连接

WebSocket使用HTTP协议通讯来进行握手, 协议升级

在TCP连接建立以后, 通过使用HTTP协议进行通信

- 如果是普通的HTTP请求, 就老样子
- 如果是想建立WebSocket连接, 就会在请求头部中带上些**特殊的头**

```http
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
```

语义是 : 浏览器想升级协议, 升级的协议是WebSocket, 同时带上一段**随机生成的Base64编码**发送给服务器

服务器接受到以后, 如果支持这个升级, 就会走WebSocket的握手流程, 根据传来的Base64编码通过**某个公开的算法**进行变换放在`Sec-WebSocket-Accept`里面穿回去

```http
HTTP/1.1 101 Switching Protocols\r\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
Upgrade: WebSocket\r\n
Connection: Upgrade\r\n
```

浏览器同样使用某个公开的算法将Base64字符串转化成另一个字符串, 然后进行比较, 如果相同, 握手成功

之后就使用WebSocket格式来传递数据

#### WebSocket格式

数据包在WebSocket中被叫做**帧**

![图片](https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png)

主要关注opcode和Payload两个字段

**opcode 字段** : 用来标识**数据的类型**

- 等于1 : text(String)类型
- 等于2 : 二进制数据([]byte)
- 等于8 : 关闭连接的信号

**payload** : 存放我们真正传递的数据长度, 单位是字节

存放长度的字段可以有`7bit`, `16bit`, `64bit`长

通过前面的7bit识别

- 如果开始的`7bit`的值是0~125, 那这7bit就代表了payload的值
- 如果开始的`7bit`的值是126, 说明还需要向后读`16bit`, 后面的`16bit`才是真正的长度值
- 如果开始的`7bit`的值是127, 说明还需要向后读`64bit`, 后面的`64bit`才是真正的长度值

**payload字段** : 存放的是传输的数据

