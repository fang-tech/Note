# TCP 三次握手与四次挥手常见面试题

## TCP基本认识

### TCP头格式有哪些内容

![TCP头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

- *序列号* : 在建立连接时计算机生成的**随机数**作为初始值, 通过SYN包传给接收端主机, **每发送一次数据就会累加一次, 用于解决网络包乱序的问题**

- *确认应答号* : 下一次期望收到的数据的序列号, 发送端收到这个确认应答以后, 可以认为在这个序列号之前的数据都已经被正常接受. **用来解决丢包问题**
- 控制位 :
  - **ACK** : 该位置为1的时候, **确认应答字段变为有效**, TCP规定除了最开始建立连接时的SYN包之外, 该位必须为1
  - **RST** : 该位置为1的时候, 表示**TCP连接出现异常**, 必须强行断开连接
  - **SYN** : 该位置为1的时候, 表示**希望建立连接**, 需要计算机生成随机值初始化序列号
  - **FIN** : 该位置为1的时候, 表示今后不会再有数据发送过来了, 希望**断开连接**. 当通信结束希望断开连接的时候, 通信双方的主机之间就可以相互交换**FIN位为1 的TCP段**

### 为什么需要TCP协议? TCP在哪一层

IP层提供的服务是不可靠的, 不能保证**网络包的交付**, 不保证网络包的**按序交付**, 也不保证网络包中的数据的**完整性**

TCP在网络层的上一层传输层, 保证了网络包传输的可靠性, 保证接收端接收的网络包是**无损坏, 无间隔, 非冗余和按序的**

### TCP是什么

TCP是**面向连接的, 可靠的, 基于字节流的**传输层协议

- **面向连接** : 必须是一对一的连接, 和UDP可以一个主机同时向多个主机发送消息, 一对多在一个TCP连接中是无法做到的
- **可靠的** : 能保证一个报文一定能够到达接收端
- **字节流** : 用户发送一个消息给接受端, 操作系统可能会将这个消息分组为多个TCP报文, 如果接收端不知道消息的边界, 是无法有效读出来用户的原消息的. 并且TCP报文是**有序的**, 当前一个报文没有收到的时候, 即使后面的报文已经收到了, 也不会交给应用层去处理

### TCP连接是什么

**用于保证可靠性和流量控制维护的某些状态信息, 这些信息的组合, 包括Socket, 序列号和窗口大小称为连接**

所以建立一个TCP连接, 客户端和服务端需要在三个信息上达成共识

- **Scoket**: 由IP:port组成
- **序列号**: 用来解决乱序问题
- **窗口大小** : 用来做流量控制

> 如何唯一确定一个TCP连接?

源地址 + 源端口, 目标地址 + 目标端口

源地址和目标地址存在IP头部中, 作用是通过IP协议发送报文给对方主机, IP协议发送报文的粒度是主机

源端口和目标端口存在TCP头部中, 告诉TCP协议应该把报文发送给哪个进程, TCP协议发送报文的粒度是进程

### TCP和UDP有什么区别呢

UDP是通过IP协议实现了**无连接**的通信服务

其头部很简单, 只有8字节

- 目标和源端口 : `4字节`
- 包长度 : `2字节`
- 校验和 : 防止收到在网络传输中受损的UDP包, `2字节`

两者的区别

*1.连接* : 

- TCP是面向连接传输的协议, 传输之前需要先建立连接
- UDP是无连接的协议

*2.传输对象*

- TCP只能实现一对一的两点之间的通信
- UDP能实现一对多, 多对一, 多对多的通信

*3.可靠性*

- TCP是可靠交付数据的, 数据可以无差错, 不丢失, 不重复, 按序到达
- UDP不保证可靠交付数据, 但是我们能通过UDP实现一个可靠的传输协议, 比如QUIC

*4. 拥塞控制, 流量控制*

- TCP有, 能保证数据传输的安全性
- UDP没有, 即使网路很拥堵了, 也不会影响UDP发送的速率

*5. 首部开销*

- TCP首部长度在没有使用\[可选]的字段的时候是`20字节`, 使用了还会更长
- UDP首部长度是固定的`8字节`

*6.传输方式*

- TCP是流式传输, 没有边界
- UDP是一个包一个包发送的, 有边界, 但是会有乱序和丢包

*7. 分片不同*

- TCP根据MSS大小, 如果大于了就会在传输层中分片, 接收方同样在传输层组装TCP数据包
- UDP根据MTU大小分片, 如果大了, 就会在IP层分片, 接收方同样是在IP层组装数据

> TCP头部中没有包长度的字段, 而UDP中有呢

其实TCP也是能计算出来负载数据的长度的

$TCP数据的长度 = IP总长度 - IP首部的长度 - TCP首部长度$

UDP中之所以会将数据作为包来处理, 其实是整个协议栈和API刻意保留了消息边界的设计, 更加强调UDP的独立性

而TCP中会将数据作为流来处理, 这是一种设计决策上和设计理念上的差异

### TCP和UDP能使用一个端口吗

**可以**

在数据链路层, MAC地址用来寻找局域网中的主机. 在网路层中, 通过IP地址来寻找网络中互连的主机或者路由器. 在传输层中, 通过端口地址寻址, 为了找到同一计算机中同时通信的不同应用进程

传输层中的端口号是为了区分不同应用进程的数据包

在内核中, 传输层协议TCP和UDP是完全独立的软件模块

当主机收到数据包以后, 根据IP包头协议号字段知道该数据包是TCP还是UDP, 从而交给不同的模块处理. 送给TCP/UDP模块的报文, 根据端口号知道送给哪个应用进程处理

## TCP连接建立

### TCP连接三次建立的过程

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 服务端先进入到`LISTEN`状态监听某个端口
- 客户端从`CLOSE`进入到`SYN_SENT`状态发送第一个报文: `SYN`报文
  - 客户端随机初始化序号(`client_isn`)给序列号
  - SYN标志为1, 表明客户端想建立一个连接
- 服务端接收到了`SYN`报文, 从`LISTEN`状态进入到`SYN_RCVD`状态, 发送第二个报文 : `ACK + SYN`报文
  - 服务端随机初始化序号(`server_isn`)给序列号
  - 把收到的客户端的`ISN + 1`填入到确认应答号中
  - `SYN`标志为1, 表明服务端想建立一个连接
  - `ACK`标志为1, 确认应答字段有效
- 客户端收到了`ACK + SYN`报文, 从`SYN_SENT`进入到`ESTABLISHED`状态, 发送第三个报文 : `ACK`报文
  - 将收到的服务端的`ISN + 1`填入到确认应答号中
  - 将`ACK`置1
- 服务端收到了`ACK`报文以后, 进入到`ESTABLISHED`状态

**第三次握手的时候是可以携带数据的, 前两次握手的时候不能携带数据**

这之后就能相互发送数据了

### 如何在linux中查看TCP状态

通过`netstat -napt`命令

### 为什么是三次握手, 不是四次或者两次?

什么是TCP连接

- 用于保证可靠性和流量控制而维护的某些状态信息, 这些信息的组合, 包括**Socket, 序列号和窗口大小**称为连接

所以问题就变成了为什么三次握手才可以初始化Socket, 序列号和窗口大小并建立TCP连接

- 三次握手才能阻止重复历史连接的初始化(主要原因)
- 三次握手才能同步双方的序列号
- 三次握手能避免资源浪费

#### 原因一: 避免历史连接

TCP连接使用三次握手的**首要原因就是为了防止\[历史连接]初始化连接造成混乱**

考虑这样的场景, 客户端线发送了SYN (seq = 90)的报文, 然后客户端宕机了, 一段时间重启以后, 重新发送了SYN (seq = 120)的报文希望重新建立连接, 但是SYN (seq = 90)的报文被网络阻塞了, 两个报文最后seq=90的先到达, 马上seq=120的也到达了服务端

三次握手是怎么阻止历史连接的

- 旧`SYN(seq=90)`先到达, 服务端接收到以后, 向客户端发送`ACK + SYN(Ack Num = 90 + 1, Seq Num = 300)`报文
- 客户端接收到以后, 发现`Ack Num`和自己期望的`Ack Num = 120 + 1`不一样, 发起`RTS`报文终止了连接
- 新的`SYN(seq=120)`到达了服务端, 服务端接收到以后, 向客户端发起了`ACK + SYN(Ack Num = 120 + 1, Seq Num = 400)`报文
- 客户端接收到以后, 发现对上了`Ack Num`, 返回`ACK(Ack Num = 400 + 1, Seq Num = 121)`报文
- 服务端接收到`ACK`报文以后, 进入到了连接`ESTABLISHED`状态, `TCP`连接建立

**如果使用两次握手, 就没有中间状态阻止历史连接, 服务端可能会建立一个历史连接, 造成资源的浪费**

因为是两次连接, 服务端在接收完`ACK + SYN`报文以后, 就会进入到`ESTABLISHED`状态, 从服务端的角度来看, 连接就已经建立好了, 这个时候服务端就可以向客户端发送消息了, 但是实际上这是一个\[历史连接], 发送的数据完全是无效浪费的,  在客户端接收到`ACK + SYN`报文以后, 向服务端发送`RST`报文以后, 连接才会被废除, 服务端**白白建立了一个不会被使用的历史连接**, **可能会导致数据的丢失, 一定造成了资源的浪费**

> TIP
>
> 第三次握手最关键的地方在于客户端发送的报文是ACK报文, 如果客户端发送完三次握手报文以后再发送了一些数据, 但是前面的三次握手报文丢失了, 这个时候连接还没有建立数据会丢失吗?
>
> 不会丢失, 因为后面的携带了数据的报文也是ACK报文, 服务端收到以后还是会建立连接, 这也是第三次握手的时候可以接收数据的一个体现

#### 原因二: 同步双方的序列号

TCP协议的通信双方, 都必须维护一个序列号

- 接收方可以通过序列号去除重复的数据
- 接收方可以通过序列号按序接收数据包
- 可以标识已经发送出去的数据包哪些被对方收到了(根据ACK报文中的序列号知道)

所以TCP不能没有序列号, 就像西方不能没有耶路撒冷

而TCP协议通信双方初始化序列号的过程可以分成下面四步

- 发送方 -> 接收方 Seq Num = client_isn
- 接收方 -> 发送方 Ack Num = client_isn + 1来确认已经成功接收
- 接收方 -> 发送方 Seq Num = server_isn 
- 发送方 -> 接收方 Ack Num = server_isn + 1

接受方和发送方都需要发送一个SYN报文来传递序列号, 另一边都需要发送一个ACK报文来表示自己已经成功收到了, 所以最少有四步, 但是接收方发送Ack Num和Seq Num能合成同一步, 所以最少需要三次握手

#### 原因三: 避免资源的浪费

如果使用两次握手, 服务端就得在发送完SYN + ACK报文以后就进入到ESTABLISHED状态, 为历史连接分配了资源, 浪费资源

#### 总结

为什么是不使用两次握手和四次握手

- 两次握手 : 没办法可靠得同步双方的序列号, 无法防止历史连接的建立, 会造成双方资源的浪费
- 四次握手 : 三次握手就已经能够理论上建立最少可靠连接, 所以不需要更多的连接次数

### 为什么每次建立TCP连接时, 初始化的序列号都要求不一样

- **如果每次建立连接的时候, 客户端和服务端初始化的序列号都是一样的, 很容易出现历史报文被下一个相同四元组的连接接收的问题**, 而如果每次建立TCP连接的时候初始序列号都不一样, 就能够区分出来历史报文和现在要接收的报文, 从而很大程度上避免了历史报文被接收
- 为了安全性, 防止黑客伪造相同序列号的TCP报文被接收

### 初始序列号ISN是如何随机产生的

ISN = M + F(loaclhost, localport, remotehost, remoteport)

- M是一个计时器, 每4微妙 + 1
- F(loaclhost, localport, remotehost, remoteport)是一个由四元组通过hash算法计算出来的随机数值. 可以使用MD5

### 既然IP层会分片, 为什么TCP层还是需要MSS呢

如果只使用IP层的MTU来分片, 就会出现下面的情况

一个IP数据报长度超过了MTU, 被切分成了多个IP分片, 然后在IP层传输, 其中的一个数据报丢失了, TCP层接收到以后无法组装成一个完整的TCP报文段, 也就无法发送给接收端, 这个时候就会在超时以后触发超时重传机制, **因为整个IP报文才具有确认机制, 所以整个IP报文会被重传**

**TCP通过MSS进行数据分段, 每个分段单独封装在TCP报文段中, 形成独立的IP数据报进行传输, 避免了IP层分片. 这使得TCP能单独确认和重传每个分段, 而不会因为单个分段丢失而重传所有数据**

###  第一次握手丢失了, 会发生什么

客户端在发送了SYN报文以后, 进入到SYN_SENT状态

如果客户端无法在规定的时间内收到服务端的SYN-ACK报文(也就是第二次握手), 就会触发超时重传机制, 重传SYN报文(Seq相同, 表示仍处于同一次TCP连接建立尝试中)

不同版本的操作系统的中的超时时间是不一样的

当客户端在1s后没有收到报文, 就会重传 ,重传的次数由tcp_syn_retries来控制

```conf
# cat /proc/sys/net/ipv4/tcp_syn_retries
5
```

第一次超时重传是在1s后, 第二次就是2s, 第三次就是4s, 第四次就是8s, 第五次就是16s, **每次超时时间是上一次的两倍**

第五次超时重传以后, 会继续等待32s, 如果还没有收到SYN-ACK, 就会断开TCP连接



### 第二次握手丢失了, 会发生什么

如果第二次握手丢失了, 就会导致

- 客户端认为自己的报第一次握手SYN报文没有发送到服务端, 进行超时重传
- 服务端一直没有收到第三次握手, 也触发超时重传

服务端超时重传的策略和第一次握手的, 每次重传的超时时间翻倍策略一样, 配置重传次数的参数是

```conf
# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

### 第三次握手丢失了, 会发生什么

也是一样的重传, 服务端认为自己的报文丢失了, 超时重传到接收到ACK或者达到最大的重传次数

### 什么是SYN攻击, 怎么避免SYN攻击

Linux内核会维护一个半连接队列和全连接队列

正常流程

- 服务端接收到客户端的SYN报文的时候, 就会创建一个半连接对象放入到半连接队列(SYN队列)中
- 接着发送SYN+ACK给客户端
- 等到接收到客户端的ACK以后, 从半连接队列中取出来一个半连接对象, 创建一个新的连接对象放入到Accept队列中
- 应用通过调用`accept()`socket接口, 从Accept队列中取出连接对象

攻击者发起SYN攻击, 就是不断使用虚假的IP:port, 然后占满SYN队列, 这样**当TCP半连接队列满了以后, 后续再收到的SYN报文就会丢失, 导致客户端无法与服务端建立连接**

解决方法

> 方式一 : 增大TCP半连接队列

通过增大下面的三个参数

- net.ipv4.tcp_max_syn_backlog
- listen()函数中的backlog
- net.core.somaxconn

> 方式二: 开启 net.ipv4.tcp_syncookies

开启这个功能就可以在不使用SYN半连接队列的情况下成功建立连接

- 当SYN队列满了以后, 后续服务端收到SYN包, 不会丢弃, 而是根据算法计算出来一个`cookie`值
- 将cookie值放入到第二次握手报文的序列号里面, 然后服务端会第二次握手给客户端
- 服务端接收到客户端的应答报文时, 会检查这个ACK包的合法性, 如果合法, 将该连接对象放入到Accept队列
- 最后应用程序通过调用`accept()`接口, 从Accept队列中取出连接

net.ipv4.tcp_syncookies的参数主要有三个值

- 0值, 表示关闭该功能
- 1值, 表示仅当SYN半连接队列放不下的时候, 再启用它
- 2值, 无条件开启功能

> 方式三 : 减少SYN+ACK重传次数

减少重传的次数, 就能减少SYN报文在SYN队列中停留的时间

## TCP连接断开

### TCP四次挥手的过程

![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

- 客户端打算关闭连接, 客户端发送`FIN`报文, 进入`FIN_WAIT_1`状态
- 服务端接受到了`FIN_WAIT_1`报文, 进入`CLOSED_WAIT`状态, 回复`ACK`报文, 服务端接受到了`ACK`报文, 进入到`FIN_WAIT_2`状态
- 服务端发送`FIN`报文, 进入`LAST_ACK`状态
- 客户端接收到了`FIN`报文, 客户端发送`ACK`报文, 进入到`TIME_WAIT`状态
- 服务端在收到`ACK`报文以后, 进入到`CLOSE`状态
- 客户端在经过`2MSL`一段时间后, 自动进入到`CLOSE`状态

主动关闭连接的, 才有TIME_WAIT状态

### 为什么挥手需要四次而不是三次?

- 关闭连接的时候, 客户端向服务端发送FIN, 仅仅表示客户端不再发送数据了但是还能接收数据
- 服务端接收到客户端的FIN报文时, 先回一个ACK报文, 而服务端可能还有数据需要处理和发送, 等服务端不再发送数据的时候, 才发送FIN报文给客户端表示同意关闭现在的连接

但是也有三次, 在被动关闭方TCP挥手的过程中, 如果没有数据要发送, 并且没有开启TCP_QUICKACK(默认没有开启), 就会启用TCP延迟确认机制, 第二次和第三次挥手就会合并

> TCP延迟确认机制

- 当有响应数据要发送的时候, ACK会和响应数据一起发送给对象
- 当没有响应数据要发送的时候, ACK将会延迟一段时间, 等待是否有响应数据可以一起发送给对方
- 如果在延迟等待发送ACK期间, 对方的第二个数据段又到达了, 就会立即发送ACK

### 第一次挥手丢失会发生什么

主动方发送的`FIN`报文丢失, 主动方在发送报文以后就进入到了`FIN_WAIT_1`状态, 主动方会在超时时间内没有接收到ACK响应报文而触发超时重传

超时时间会随着超时次数翻倍

重发次数通过`tcp_orphan_retries`参数来控制

### 第二次挥手丢失会发生什么

被动方接收到了发起方的`FIN`报文, 进入到`CLOSE_WAIT`状态

但是ACK报文是不会重传的, 从发起方的角度来看, 就是自己的第一次挥手丢失了, 就会超时重传第一次挥手



### 第三次挥手丢失会发生什么

发起方接收到ACK报文以后, 进入到` FIN_WAIT_2`状态, 需要接收到被动方发送的`FIN`报文才能进入到`TIME_WAIT`状态

从客户端的角度来看就是一直没有接收到被动方发送的FIN报文, 一直在FIN_WAIT_状态, 从服务端的角度来看, 就是发送的FIN丢失了, 超时重传, 超过了设定的重试次数, 就会从服务端断开连接

如果主动关闭方使用的关闭函数是`close()`函数, 它有一个`tcp_fin_timeout`的参数, 控制了在`FIN_WAIT_2`阶段的最长时间, 如果超过了这个时间, TCP连接会被强行关闭, 从客户端断开丽娜姐

如果使用的是`shutdown()`函数, 那就是死等了

### 第四次挥手丢失会发生什么

客户端在第三次挥手以后就会进入到TIME_WAIT阶段, 2MSL之后就会从客户端关闭连接

- 服务端重传`FIN`报文的次数达到`tcp_orphan_retries`的最大重传次数的时候, 等待上次等待时间的两倍以后, 就会从服务端断开连接
- 客户端进入到`TIME_WAIT`阶段以后, 开启2MSL的定时器, 如果收到`FIN`报文, 就会重置定时器, 定时器到了, 就从客户端关闭连接

### 为什么TIME\_WAIT等待的时间是2MSL

`MSL` : Maximum Segment Lifetime, 报文的最大生存时间, 任何报文在网络上存在的最长时间

MSL与TTL的区别 : **MSL的单位是时间, TTL是经过路由跳数**

**TTL的值一般是64, Linux将MSL的值设置为30s, 意味着Linux认为数据经过64个路由器的时间不会超过30s, 如果超过了, 就认为报文已经消失在网络中了**

TIME_WAIT等待2倍的MSL, 比较合理的解释是 : 网络中可能存在发送方发送过来的数据包(也就是第三次挥手的FIN包), 接收到这个包的最长可能时间是一个MSL, 然后接收到以后又会给对方响应, 这个最大可接受时间又是一个MSL

相当于至少允许报文丢失一次, 如果ACK在一个MSL内丢失, 这样被动方重发的FIN会在第2个MSL内到达

### 为什么需要TIME_WAIT状态

TIME_WAIT是只有主动方才有的状态

- 防止历史连接中的数据, 被后面相同的四元组连接错误接收
  - 2MSL的时长能保证历史数据包都已经自然消失在网络中了
- 确保被动关闭连接的一方能正确关闭
  - 等待足够的时间,  保证自己的ACK是能被对方收到的, 从而帮助其自然关闭

### TIME_WAIT过多有什么危害

- 占用系统资源, 比如文件描述符, 内存资源, CPU资源, 线程资源等, 简单来说就是在TIME_WAIT过多会导致资源得不到快速的释放
- 占用端口资源, 端口资源是有限的, 一般范围是`32768 ~ 61000`, 可以通过修改net.ipv4.ip_local_port_range
  - 如果客户端(主动发起关闭连接方)TIME_WAIT状态过多, 就没办法再向[目的IP, 目的PORT]一样的服务建立连接了, 因为四元组相同

### 如何优化TIME_WAIT

优化的点在于TIME_WAIT会延缓资源释放的时间, 解决最短等待时间是`2MSL`的问题

*方式一 : net.ipv4.tcp_tw_reuse和tcp_timestamps*

开启`net.ipv4.tcp_te_reuse = 1`以后, 可以复用处于TIME_WAIT的socket为新的连接所用

**tcp_twreuse功能只能是客户端(连接发起方), 因为开启了这个功能,  在调用connect()函数的时候, 内核会随机找出来一个time_wait状态超过1s的连接给新的连接复用**

开启这个功能的一个前提是, 需要打开TCP对时间戳的支持

`net.ipv4.tcp_timestamps = 1(默认为1)`
引入了时间戳, 就不需要通过等待2MSL来确保历史数据已经消失在网络中, 因为时间戳过期的数据包自然会被丢弃

*方式二: net.ipv4.tcp_max_tw_buckets*

这个值默认是18000. **当系统中处于TIME_WAIT的连接一旦超过这个值, 系统无法为这些新关闭的连接分配TIME_WAIT状态的资源, 会直接关闭资源, 也就是向这些连接发送RST包而不是FIN包**

*方式三: 程序中使用SO_LINGER*

通过设置socket的选项, 来设置调用close关闭连接行为

```c
struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger, sizeof(so_linger));
```

如果`l_onoff`为非0, 且`l_linger`的值为0, 调用`close`以后, 就会立刻发送一个`RST`报文给对端, 该TCP连接将跳过第四次挥手

上面的三种方法其实都是在想办法跳过TIME_WAIT状态, 会发生乱七八糟的事情的, 毕竟它设计出来就是为了给下一个TCP连接一个纯净的环境

**如果服务端要避免过多的TIME_WAIT状态的连接, 就永远不要主动断开连接, 让客户端去断开, 由分布在各处的用户端来承受TIME_WAIT**
