# 如何基于UDP实现可靠传输

## 为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)

TCP有四大缺点

- TCP的升级很困难
- TCP存在队头堵塞
- TCP建立连接的延迟
- 网络迁移需要重建TCP连接

QUIC协议的实现, 也是主要聚焦于解决这些问题

## QUIC是怎么实现可靠传输的

拿HTTP3举例说明, 在UDP报文和HTTP消息之间, 有三层协议

![](https://cdn.xiaolincoding.com//mysql/other/http3-over-quic-protocol-works.png)

- Packet Header
- QUIC Frame Header
- HTTP3 Frame Header

### Packet Header

Packet Header细分成两种

- Long Packet Header 用于首次建立连接
  - 源连接ID长度, 源连接ID
  - 目标连接ID长度, 目标连接ID
- Short Packet Header 用于日常传输数据
  - 目标连接ID
  - 编号 Packet Number
  - 负载数据

`Packet Number`是每个报文独一无二的编号, 是严格递增的, 也就是如果Packet N丢失了, 重传的Packet N的`Packet Number`也不是N了, 而是一个比N大的值

这样设计的原因, 主要是为了解决TCP协议中, 发生超时重传以后, 客户端无法判断出来是原始报文的响应还是重传报文的响应, 会导致RTT的计算不准(解决方案是忽略被重传过的报文的RTT值)

同时还能使QUIC支持乱序确认

所以Packet Number严格递增的好处有

- 可以更加精确计算出来RTT, 没有TCP重传的歧义性
- 可以支持乱序确认

![TCP 重传的歧义问题](https://img-blog.csdnimg.cn/7e4e778413c1452bb6d58ec3d5452316.png)

![](https://img-blog.csdnimg.cn/ca91985c9a94487a8a29db1249109717.png)

>  维护连接状态的意义, 为什么要维护连接, 明明四元组不是已经能唯一确定传输的对象

面向连接可以理解为, 这个协议是会维护连接双方的一些**状态信息**的, 比如**序列号**, **窗口大小**等, TCP正是通过面向连接, 才实现了可靠的保序的传输, 像HTTP就不是一个面向连接的协议, 因为它一个**无状态的协议**

而对于QUIC, 双端通过目标连接的ID来唯一映射到一条连接上

通过这个连接状态, QUIC实现了

- 真正的**连接迁移**, 因为连接的映射不再依赖于四元组, 而是依赖于更加抽象的目标连接ID, 每一个UDP数据段都能通过目标连接ID来找到自己的连接
- **状态恢复与0-RTT重连**, 会在更快的连接建立说明

> 使用QUIC协议通信的双方是怎么协商出目标连接ID的

在初始建立连接的阶段, 发起方会随机生成一个连接ID(源连接ID, Source Connection ID SCID), 并且会在发送初始包的时候携带这个ID

被动方接收到这个初始包以后, 也会生成自己的SCID, 并且在回复客户端的时候附带这个ID, 被动方将发起方的SCID作为自己的目标连接ID(Destination Connection ID DCID)放入到回复包中

最后发起方接收到回复包以后, 就会将被动方的SCID当作自己的DCID

接下来两者之间的通信就只会有DCID, 用于确认这条消息属于哪个连接

### QUIC Frame Header

一个Packer 报文里面可以有多个QUIC Frame报文

![](https://img-blog.csdnimg.cn/6a94d41ef3d14cb6b7846e73da6c3104.png)

Frame有很多种, 这里讨论Stream类型的Frame格式

- Stream ID : 多个并发传输的HTTP消息, 通过Stream ID加以区别, 和HTTP/2的Stream ID类似
- Offset : 类似于TCP协议中的Seq序号, 保证数据的顺序性和可靠性
- Length : 指明了Frame数据的长度
- 负载数据

如果数据包 Packet N丢失了, 那么我们是怎么确认重传的Packet N+M是同一个数据包呢

通过Stream ID + offset, 如果两个数据包的Stream ID + offset都是一致的, 说明就是同一个数据包

**QUIC通过单向递增的Packet Number配合Stream ID 和offset字段信息, 可以支持乱序确认而不影响数据包的正确组装**

### QUIC的乱序确认

首先我们得看到TCP的累计确认机制

- 只确认连续序列, 发送方收到ACK 3, 说明接收方收到了1, 2, 3但是不能说明没有收到4,5,...
- 缓存失序数据
- 确认号表示期望, 表示的是期望收到的下一个TCP段的序列号

QUIC支持乱序确认

发送方按序发送(按offset的顺序发送)发送窗口中的缓冲区中的30~36数据包(这里的数字是Packet Number)

31, 32数据包首先被确认(QUIC支持乱序确认, 不需要等待Packet 30被确认)

在30被接收到以后, 缓冲区收缩为33 ~ 36, 这个时候缓冲区收缩到了阈值, 接收方发送MAX_STREAM_DATA Frame (协商缓存大小的特定帧), 请求增大最大绝对字节偏移量(就是缓冲区最右边的offset, 其实就是在请求发送缓冲区的右边界向右滑动)

发送缓冲区的右边界向右滑动

将超时的Packet 33重新变成Packet 42重新发送

> 为什么能通过Packet Number配合Stream ID和offset来支持乱序确认, 但是TCP却不行呢

- Packet Number是连接级别的序列号空间(位于传输层, 用于标识每个UDP数据包), offset是Stream级别的序列号空间

  - QUIC协议通过ACK帧来选择性确认Packet Number, 如果重传了以后出现了重复(通过Stream ID  + offset判断, 会直接丢弃就行)

  - 举例说明一个ACK帧：

    - 最大确认号：100 (已经收到的最大包序号)
    - 第一个ACK范围：30（表示包70-100已收到）
    - 间隙1: 10 (与前一个范围间隔10个)
    - ACK范围1：15（表示包45-59已收到）
    - 间隙2: 5 (与前一个范围间隔5个)
    - ACK范围2：10（表示包30-39已收到）

    这表示接收方已收到的包序号为：30-39、45-59和70-100，而40-44、60-69的包尚未收到。

- 通过选择性确认实现了对于UDP包的乱序确认以及可靠传输

- 通过StreamID + offset实现了数据包的正确组装

## QUIC是如何解决TCP队头堵塞的问题的?

### 什么是TCP的队头堵塞问题

**发送窗口只有窗口中的已发送未收到ACK确认的数据被确认了, 窗口的左边界才会向右滑动, 但是如果其中有一个数据丢失了, 左边界就会阻塞在丢失的数据上, 因为它一直得不到确认**

**接收窗口中某个低序号的数据丢失了, 即使高序号的数据接收到了, 窗口的左边界也会被这个丢失的数据阻塞住, 同时也不会将数据交付给应用层, 缓冲区就会被一直占用着**

### HTTP/2的队头阻塞

HTTP/2抽象出来了Stream概念, 实现了HTTP的并发传输, 一个Stream就代表HTTP/1.1中的一个请求和响应(在HTTP/1.1中, 如果有一个HTTP请求阻塞了, 因为HTTP的请求-响应模型, 会导致所有的HTTP请求都被阻塞住)

在HTTP/2中, 不同Stream的帧是可以乱序发送的, 每个帧的头部都会携带Stream ID信息, 但是一个Stream内部的帧必须是严格有序的

但是HTTP/2还是在传输层的TCP协议上实现的应用层协议, 虽然在应用层上解决了不同HTTP请求之间的队头堵塞问题, 但是受限于TCP的队头堵塞问题

**如果有一个Stream中的一个数据丢失了, 会阻塞所有的Stream**

### 没有队头堵塞的QUIC

**QUIC为每个Stream都分配了一个独立的滑动窗口**, 完全解决了队头堵塞问题

如果Stream 2丢失了一个数据包, 也只会影响Stream 2

## QUIC是怎么做流量控制的

TCP的流量控制是让接收方告诉发送方, 自己的接收窗口有多大, 从而让发送方根据接收方的实际接收能力控制发送的数量

QUIC实现流量控制的方式

- 通过window_update帧告诉对方自己可以接收的字节数, 这样发送方就不会发送超过这个字节数的数据
- 通过BlockFrame告诉对端由于流量控制被阻塞了, 无法发送数据

### Stream级别的流量控制

QUIC的接收窗口的**左边界滑动条件取决于接收到的最大偏移字节数**

`接收窗口 = 最大窗口数 - 接收到的最大偏移数`

**右边界的滑动条件是接受窗口内的已收到并被上层读取的数据超过接收窗口的一半**(应用层读取的数据一定是保序的,  所以这部分数据一定是连续的都收到了的)

**如果中途丢失了数据包, 会导致已收到并被上层读取到的数据没有超过接收窗口的一半, 最终右边界无法滑动, 造成阻塞**

### Connection级的流量控制

整个Connection的可用窗口 = 所有Stream的可用窗口大小之和

## QUIC对拥塞控制的改进

简单来说就是, QUIC支持很多的拥塞控制算法, 同时因为它更新很方便, 能有比较快的迭代速度迭代拥塞控制算法

甚至可以根据不同应用设置不同的拥塞控制算法

## QUIC更快的连接建立

对于HTTP/1.1或者HTTP/2, TCP和TLS是分层的, 分别属于内核的传输层和openssl库实现的表示层, 因此很难被合并在一起, 需要分批次来握手, 先TCP握手(1RTT), 再TLS握手(2RTT), 所以需要3RTT的延迟才能传输数据, 就算Session会话复用, 也需要至少2RTT

但是在HTTP/3的QUIC协议并不是与TLS分层,而是**在QUIC内部包含了TLS, 在自己的帧中携带TLS里的记录, 再加上QUIC使用的是TLS1.3, 仅需要1个RTT就能同时建立连接和密钥协商, 在第二次连接的时候, 应用数据包可以和QUIC握手信息(连接信息 + TLS信息)一起发送, 达到0-RTT的效果**

![](https://img-blog.csdnimg.cn/4cad213f5125432693e0e2a512c2d1a1.png)

## QUIC迁移连接

QUIC协议中的连接不依赖于四元组来确认, 而是依赖于连接ID这个再度抽象了一层的状态来确认连接, 所以在IP切换了以后, 只要仍然有连接ID, TLS密钥等, 依然可以无缝复用原连接, 连接随便迁移