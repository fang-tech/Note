# 内存管理-为什么要有虚拟内存

## 如果没有虚拟内存

如果没有虚拟内存, 也就意味着我们的程序需要直接和物理内存进行交互, 我们需要直接操作物理内存地址, 那么问题来了, 我们怎么保证我们的程序操作的物理内存地址, 别人的程序没有在操作, 这个物理地址是安全可直接操作的?

## 虚拟内存

虚拟内存就是上面直接操作物理地址会导致的问题的解决方案, 操作系统在物理内存和程序之间提供一个抽象层, 我们将内存虚拟化, 我们让每个程序都看似拥有一整个内存空间, 可以访问可行的所有内存地址, 无关物理内存的大小, 物理内存的地址. 将虚拟内存和物理内存之间的映射交给操作系统管理

这样我们的程序就不需要再考虑这个内存地址是不是正在被其他的程序使用, 不需要再考虑其他的程序对自己内存的影响, 因为所有的程序都有自己的虚拟内存, 相互独立

在有了虚拟内存以后, 我们访问一个内存地址的过程会变成

- CPU 携带虚拟地址 -> MMU -> 访问到物理地址

![](https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png)

> 那么操作系统是怎么管理虚拟地址和物理地址之间的关系?

主要通过内存分段和内存分页两种方式

## 内存分段

内存分段的理念是基于程序是有若干个逻辑分段组成的. 不同的段有不同的属性, 所以就用分段的形式将段分离出来

> 在分段机制下, CPU是怎么访问一个物理内存地址的?![](https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png)

分段机制下的虚拟地址分为两部分 : **段选择因子**, **段内偏移量**

- 段选择因子
  - 段号 : 用作段表的索引, 最重要的属性
    - 段表中保存的是这个段的基址, 段的界限, 特权等级等
  - 特权等标志位

![](https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png)

通过段号 + 段内偏移量, 从段号我们能知道段基址, 再将段基址加上段内偏移量就是物理地址, 以此完成了虚拟地址到物理地址之间的转换分段的方法会导致两个问题

- 内存碎片
  - 内部碎片 : 段内分配了比需要的内存更多的内存
  - 外部内存碎片 : 由于每个段的长度不固定, 在运行的时候, 我们创建和释放段, 就会出现我们有256M的空闲空间, 但是这个256的空间实际上是不连续的, 被分成两个128M, 这个时候我们就无法再创建一个200M的段
- 内存交换的效率低
  - 在分段方法下, 内存交换的最小单位变成了段, 而段的大小是不确定的, 我们很容易出现需要交换大小很大的段, 磁盘的访问速度比内存慢很多, 最后就会导致机器卡顿(这个交换的过程是阻塞的, 同时内存交换能解决外部内存碎片的问题, 我们可以将内存中的内容swap到磁盘中, 再重新加载到的内存中, 重新加载的时候, 让这些内存连续, 这个时候就能空出256M的连续空间)

## 内存分页

内存分段的主要问题是外部内存碎片和内存交换的空间太大的问题, 要解决这些问题, 我们就需要有能少出现一些内存碎片的方法 : **内存分页(Paging)**

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**, 在Linux中的, 每一页的大小为 `4KB`

虚拟地址和物理地址之间通过**页表**映射

- CPU -> 虚拟内存 -> 页表(MMU) -> 物理地址
- 当进程访问的虚拟地址在页表中查询不到的时候, 就会触发 **缺页异常**, 进入系统内核态分配物理空间更新进程页表, 再返回用户态, 恢复进程的运行
  - 也就是说, 实际上分配物理内存的时刻是发生在第一次访问的时候, 而不是申请这块内存的时候
  - 分页的方式使得我们在加载程序的时候, 不再需要一次性将程序加载到物理内存中, **只建立虚拟内存和物理内存之间的页的映射**之后, 在程序运行中, 需要用到对应的虚拟内存页中的指令和数据的时候, 再加载到物理内存中, 实现了**按需加载**, 而不是**预加载**




> 所以分页是怎么解决分段的 [外部内存碎片和内存交换效率低] 的问题的?

因为采用了分页的机制, 而页和页之间是连续紧密排列的, 所以不会有外部内存碎片

我们swap的最小单位不再是不确定大小的段, 而是页, 更细粒度, 如果内存空间不够, 操作系统会把其他正在运行中的 [最近没有使用] 的内存页面释放出来, 暂时写在硬盘上, 这个过称作 **换出**. 而一旦有需要, 再从磁盘中加载进来, 这个过程称为 **换入**. 更加细粒度的交换, 并且是按需和使用频率交换, 能有效提高内存的交换效率

> 分页机制下, 虚拟地址和物理地址之间是怎么建立映射的?

分页机制下, 虚拟地址分为**页号**和**页内偏移量**两部分

![](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)

查询过程为

1. 通过虚拟页号我们在页表中查询到物理页号
2. 再将物理页号加上页内偏移量, 得到物理内存地址

> 简单的分页机制有什么缺陷吗?

因为我们给每个程序都制造了他们拥有所有的页的假象, 所以我们需要为每个程序都建立一个页表用于映射虚拟页号和物理页号, 一页的大小是2^12, 4GB是2^32, 也就是有2^20个页, 每个页表项需要4个字节存储, 那么整个4GB的内存空间就需要2^22的内存, 也就是4MB的内存来存储页表

100个进程, 光是页表就需要400MB的内存, 这个开销过大了, 换成64位的环境, 会变得更糟糕

### 多级页表

为了解决的上面的我们需要为每个程序创建一个完整的页表的问题, 我们采用**多级页表**技术

> 多级页表是怎么解决上面的问题的?

我们将2^20大小的页表分成两级, 每级页表的大小是`1KB`,  在多级页表的机制下, 我们从虚拟地址访问到物理地址需要

1. 虚拟地址中有一级页号和二级页号
2. 通过一级页号定位二级页表的地址
3. 通过二级页表和页内偏移量访问到对应的物理内存地址

看似多级页表机制反而让我们建立页表的开销变得更大了, 现在需要`4KB` + `4MB`的大小存储页表, 但是多级页表最关键的点在于我们能按需创建页表, 而根据空间局部性原理, 程序实际需要访问的内存地址只有很小一部分, 这就导致最后`4MB`的二级页表只会被创建很小一部分, 就像

- 我们现在需要去找到一个地方
- 单极页表就是一张非常详细的大的地图, 这个地图一次性加载的代价很高
- 而多级页表就是开始给了我们一张很粗略的地图只有国家, 我们到了对应的国家以后, 再申请获取一张更详细的国家地图, 我们再访问对应的更详细的地址(这个申请更详细地图的行为, 是程序向系统发起的)

![](https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png)

在64位的系统中, 页表不只有两级, 而是被分成了四级

- 全局页目录项 PGD（*Page Global Directory*）；
- 上层页目录项 PUD（*Page Upper Directory*）；
- 中间页目录项 PMD（*Page Middle Directory*）；
- 页表项 PTE（*Page Table Entry*）；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.png)

### TLB

多级页表虽然解决了空间上的问题, 但是在时间上带了额外的开销, 现在我们要将我们的虚拟地址转化为物理地址, 需要更多的工序

利用局部性原理, 很轻车熟路地, 我们只需要将我们常用的页表项存储到访问速度更快地硬件上, 所以我们现在又多了一个专门存放程序最常访问地页表项地Cache : TLB

## 段页式内存管理

将内存分段和内存分页结合起来就是**段页式内存管理**

![](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)

段页式内存管理的实现方式

- 先通过程序的逻辑意义, 将内存分为多个段
- 将段分成多个页, 也就是对段划分出来的连续空间再划分成固定大小的页

这样虚拟地址就由**段号**, 页号, **页内偏移量**三部分组成

> 段页式访问内存的过程

1. 通过段号得到对应的页表
2. 通过虚拟页号, 在页表中查询到物理页号
3. 物理页号 + 页内偏移量查询到具体的物理地址

## Linux内存布局

Linux内存主要使用的是内存分页的方式, 但是因为Intel处理器的使用段页式内存管理, Linux不可避免地涉及了段机制

但是Linux中, 每个段的开始的地址都是0x0, 每个段空间都是整个4GB的虚拟空间(32位的环境下), 这种做法下相当于屏蔽了处理器中的段的概念, 段只被用于访问控制和内存保护

Linux将虚拟地址空间分为内核空间和用户空间

![](https://cdn.xiaolincoding.com//mysql/other/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png)

对于每个进程来说, 用户空间是相互独立的, 但是关联的都是相同的物理空间

![](https://cdn.xiaolincoding.com//mysql/other/48403193b7354e618bf336892886bcff.png)

## 总结 - 虚拟内存的三大核心价值

- 允许进程使用超过物理内存大小的进程空间 ( 通过交换机制 )
- 提供进程间内存隔离, 每个进程拥有独立的内存空间
- 通过页表的权限标记实现内存访问控制和保护

