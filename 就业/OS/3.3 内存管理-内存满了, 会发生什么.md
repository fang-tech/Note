# 内存管理-内存满了会发生什么

## 内存分配的过程

1. 在CPU第一次访问虚拟地址的时候, 发现这个虚拟内存没有映射到实际的物理内存, 这个时候就会触发缺页中断, 将中断交给缺页中断函数处理
2. 中断函数判断是否有空闲的物理内存
   1. 有则直接分配内存, 并建立物理内存和虚拟内存之间的映射关系
   2. 没有则会开始**回收内存**的工作
3. 后台内存回收 : 唤醒kswapd内核线程来回收内存, 这个过程是 **异步** 的
4. 直接内存回收 : 后台异步回收内存跟不上进程内存申请的速度, 就会直接开始回收, 这个回收的过程是**同步**的, 也就是会阻塞进程的运行
5. 直接内存回收后, 空闲的物理内存仍然无法满足这次的物理内存的申请, 就会触发 OOM 机制, OOM
    Killer 机制会根据算法选择一个占用物理内存较高的进程, 并将其杀死, 直到释放足够的内存, 这个时候内存分配函数也会返回失败, 同时在释放的过程中申请内存的进程如果分数过高, 也可能被杀掉

![](https://cdn.xiaolincoding.com//mysql/other/2f61b0822b3c4a359f99770231981b07.png)

## 可回收的内存类型

主要是两类内存

- 文件页 : 内核缓存的磁盘数据和内核缓存的文件数据都叫做文件页. 将文件页释放是件安全风险很低的事情, 大不了以后再从磁盘中读取就是了. 回收干净页的方式是直接释放内存, 回收脏页的方式是先写回磁盘, 再释放内存
- 匿名页 : 没有实际的载体, 是一个程序的上下文, 比如堆, 栈数据等. 这部分数据很可能还要再被访问, 不能直接释放, 不然就丢失数据了, 回收的方式是通过Linux的Swap机制, 会将这些数据写入到磁盘中, 再释放, 下次使用的时候再从磁盘中写回

两类内存的回收都是基于LRU算法,  优先回收不常访问的内存. 具体的实现会在4.5详细说明

## 回收内存导致的性能异常的常见处理方式

回收内存的性能瓶颈在于磁盘的IO

### 调整文件页和匿名页的回收倾向

回收文件页触发的磁盘IO次数比匿名页的次数少些, 所以让操作系统队文件页的回收倾向更大, 能减少磁盘的IO次数, 提高一定的性能

Linux提供了/proc/sys/vm/swappiness 的参数来设置回收倾向, 数值越大, 越积极使用swap, 也就是越倾向于回收匿名页; 数值越小, 越消极使用swap, 也就更倾向于回收文件页

### 尽早触发kswapd内核异步线程回收内存

> 我们该怎么发现现在系统的抖动是直接内存回收导致的?

通过 `sar -B 1` 命令观察

![](https://cdn.xiaolincoding.com//mysql/other/8acb6b28d0fc4858bd57be147d087def.png)

图中红色框住的就是后台内存回收和直接内存回收的指标，它们分别表示：

- pgscank/s : kswapd(后台回收线程) 每秒扫描的page个数
- pgscand/s : 应用程序在内存申请过程中每秒直接扫描的page个数
- pgsteal/s : 扫描的page中每秒被回收的个数 (pgscank + pgscand)

也就是如果系统发生抖动的时候, pgscand的值很大, 那大概率是由 [直接回收内存] 导致的

解决方式就是尽早触发kswapd内核异步线程回收内存

> 什么时候会触发kswapd内核线程回收内存呢

内核定义了三个阈值, 来衡量当前剩余内存是否充裕或者紧张

- 页最小阈值
- 页低阈值
- 页高阈值

 ![](https://cdn.xiaolincoding.com//mysql/other/166bc9f5b7c545d89f1e36ab8dd772cf.png)

kswapd会定期扫描内存的使用情况, 根据剩余内存的情况来进行内存回收的工作

- 图中橙色部分 : 如果内存剩余在页低阈值和最小阈值之间的时候, 会**kswapd0会执行内存回收, 直到剩余内存大于高阈值为止**
- 图中红色部分 : 说明用户可用内存基本都耗尽了, 此时会触发直接内存回收, 这个时候应用程序就会被阻塞

也就是如果我们想尽早触发kswapd系统异步回收线程, 就需要增大页低阈值, 而页低阈值是通过设置最小阈值间接设置的

```
pages_min = min_free_kbytes
pages_low = pages_min*5/4
pages_high = pages_min*3/2
```

页最小阈值能通过内核选项 `/proc/sys/vm/min_free_kbytes` 设置

但是增大了以后, 会使得系统预留过多的内存空间空闲, 浪费了内存, 所以在调整之前, 我们需要思考程序更关注什么, 如果更关注延迟, 就能适当增大min_free_kbytes

## 如何保护一个进程不会被OOM杀掉呢

Linux内核里有一个`oom_badness()`函数, 会把系统中可以被杀掉的进程都扫描一遍, 并对每个进程进行打分,  得分最高的进程会被首先杀掉

得分的计算

```
// points 代表打分的结果
// process_pages 代表进程已经使用的物理内存页面数
// oom_score_adj 代表 OOM 校准值
// totalpages 代表系统总的可用页面数
points = process_pages + oom_score_adj*totalpages/1000
```

oom_score_adj越大, 进程越容易被杀掉, 每个进程中这个参数都默认为0

- oom_adj的范围是-1000 ~ 1000

## 在物理内存4G的机器上申请8G的内存会发生什么

- 在32位的系统上, 进程理论上最大能申请3 GB大小的虚拟内存, 所以直接申请8GB内存, 会失败
- 64位的系统上, 因为进程理论上最大能申请128TB大小的虚拟内存, 即使物理内存4GB, 申请8GB内存也没有问题, 如果这块虚拟内存被访问了, 需要看系统有没有Swap分区
  - 有分区, 即使4GB, 程序也能正常使用8GB内存, 进程正常运行
  - 没有分区, 物理空间不够, 进程会被操作系统杀掉, OOM