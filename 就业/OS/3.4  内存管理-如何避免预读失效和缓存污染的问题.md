# 内存管理-如何避免预读失效和缓存污染的问题

其实这两个问题都是在问如何改进LRU算法

Redis通过实现LFU算法来避免缓存污染而导致缓存命中率下降的问题

MySQL和Linux操作系统通过改进LRU算法来避免预读失效和缓存污染

## Linux和MySQL的缓存机制

Linux的page cache和MySQL的Buffer Pool缓存的基本数据单位都是页

### Linux的缓存

在应用程序读取文件的数据的时候, Linux操作系统会对读取的文件数据进行缓存, 缓存在文件系统的Page Cache中

### MySQL的缓存

读取的数据时, 如果数据存在于Buffer Pool 中时, 客户端会直接读取缓存中的数据, 否则从磁盘中读取

修改数据的时候, 首先修改Buffer Pool中的数据, 然后将页设置为脏页, 最后由后台线程将脏页写入到磁盘中

## 解决预读失效

### 什么是预读机制



Linux操作系统为基于Page Cache的读缓存机制提供预读机制

- 应用程序只想读取磁盘文件A的offset为0 ~ 3KB范围内的数据, 但是磁盘的基本读写单位时block(4KB), 所以操作系统至少会读取0~4KB的内容
- 同时操作系统出于空间局部性原理, 会将磁盘块 offset [4KB, 8KB), [8KB, 12KB), [12KB, 16KB)都加载到内存中, 额外申请了3个page

![](https://img-blog.csdnimg.cn/img_convert/ae8252378169c8c14b8b9907983f7d8b.png)

MySQL Innodb存储引擎的Buffer Pool也有类似的预读机制, MySQL从磁盘中加载页的时候, 会提前将它相邻的一页一并加载进来

### 预读失效会带来什么问题

如果预读的时候提前加载进来的页没有被访问, 就是预读失效

如果使用传统的LRU算法, 就会把预读页放到LRU链表头部, 内存空间不够的时候就将末尾淘汰掉

如果这些预读页不会被访问到, 就会出现, 不会被访问的预读页却占据了LRU的前排的位置, 而末尾淘汰的页, 可能是热点数据, 这样就大大降低了缓存命中率 

### 如何避免预读失效造成的影响

让预读页停留在内存里的时间要尽可能的短, 让真正被访问的页才移动到LRU链表的头部, 从而保证真正被读取的热点数据停留在内存里的时间尽可能长

- Linux操作系统实现了两个LRU链表, **活跃LRU (active_list), 非活跃LRU(inactive_list)**
- MySQL地Innodb存储引擎是在LRU链表上划分来2个区域: **young区域和old区域**

这两种解决方案都是为了将数据分为冷数据和热数据, 分别LRU

> Linux如何避免预读失效带来的影响

- 预读页就会被加入到 inactive list区域的头部
- 访问inactive_list中的数据, inactive_list中的数据会**升级**到active_list的头部, 然后将active_list的末尾数据**降级**到inactive_list的头部

> MySQL Innodb如何避免预读失效

其实是基本类似的设计, 只不过Linux分成了两个链表, 而MySQL一个链表, 但是划分成了两部分

**预读的页只加入到old区域的头部, 当页被真正访问的时候, 才会将页插入到young区域的头部, 并将young区域的最后一个元素顺位到old区域的头部**

## 解决缓存污染

### 什么是缓存污染

如果还是使用 [只要数据被访问一次, 就将数据加入到活跃LRU链表头部, 这种方式的话, 就还存在着缓存污染的问题]

在我们批量读取数据的时候, 由于数据被读取了一次, 这些大量数据都会被加入到[活跃LRU链表]里, 然后真正的热点数据就全被淘汰了, 如果这些大量的数据不是热点数据的话, 那么整个活跃LRU链表都被污染了

### 如何解决缓存污染

其实我们对于这个问题有个很奇妙的切入点在于, 解决缓存污染的核心在于识别出热点数据, 我们可以通过识别出来这个数据是不是由空间局部性带来的访问

- **Linux操作系统** : 在内存页被**第二次**访问的时候, 才将页**升级**
- MySQL Innodb : 在内存页被**第二次**访问的时候, 还会进一步判断停留在old区域的时间
  - 如果第二次**访问时间**与第一次访问的时间在**1s内**, 就**不会**被升级
  - 如果停留时间**超过1s**就会升级