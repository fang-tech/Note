# OS硬件结构

## 中央处理器 (CPU : Central Processing Unit)

### 位数

- 常见的cpu有32位和64位的cpu, 这里的位数指的是cpu的带宽
    - 即cpu一次能计算多少字节的数据
    - 32bit : 一次可以计算4字节
    - 64位 : 一次可以计算8字节
- cpu的位宽越大, 一次性能计算的数据量就能越大

> 那么如果一个32位的CPU只能计算32位的数据吗

- 一个32位的CPU可以计算大于32位的数据
    - 32位指的是寄存器宽度为32为位, 数据总线位32位, 一次可以处理32位的数字
    - 可以通过**多周期分段算法**, 将一个数字分成多个32的片段, 就像串联式的加法器一样实现拓展

> 这里的32位的数据指的是最后运算结果不能超过32位还是参与运算的数字不能超过32位

- CPU单次运算中操作数的位宽上限时32位
    - 操作数长度限制32位
    - 寄存器宽度限制32位, 超过32位的数据无法一次性处理, 需要拆分为多次计算

### 为什么使用寄存器

> 已经有了内存了, 为什么我们还需要寄存器存储CPU数据

- **用途上的区别**
    - **寄存器** : 临时存放CPU直接处理的数据和指令, 强调快速访问
    - **内存** : 存储运行时程序及数据, 以及需要长期保留的数据, 强调容量大, 长期保存
- **物理位置上的区别**
    - 寄存器距离CPU更近, 能在更短的时钟周期内做出响应
- **数量上的区别**
    - 寄存器的数量很少

- **本质原因**
    - 使用寄存器, 本质上是因为内存的访问速度远低于CPU的计算速度, 我们需要一个存储区域能匹配CPU的运算速度, 用于储存CPU运算过程中, 产生的大量临时的数据, 提高整体的性能

## 寄存器 (了解)

### 1. 通用寄存器

- **数据寄存器 (如 AX, BX, CX, DX)** 
    - 存储运算过程中的数据, 运算结果, 地址偏移量等

### 2. 地址寄存器

- **指针寄存器 (SP, BP)**
    
    - SP (Stack Pointer, 栈指针)
        - 指示当前栈顶的位置, 用户函数调用时的压栈和出栈操作
    - BP (Base Pointer, 基址指针) 
        - 存放栈中的某个数据区域的起始地址, 通常用于定位栈中的局部变量
 
 - **变址寄存器（如SI、DI）：**
    
    - SI（Source Index，源变址寄存器）：
        - 存储源数据的偏移地址，常用于字符串、数组数据复制。
    - DI（Destination Index，目的变址寄存器）：
        - 存储目标数据的偏移地址，也用于字符串、数组数据操作。
### 3. 段寄存器（Segment Registers）

- **CS（Code Segment，代码段寄存器）：**
    - 存储当前程序执行代码段的起始地址。
 - **DS（Data Segment，数据段寄存器）：**
    - 存储程序数据段的起始地址。
- **SS（Stack Segment，堆栈段寄存器）：**
    - 存储堆栈段的起始地址。
- **ES（Extra Segment，附加段寄存器）：**
    - 存储附加数据段地址，通常用于额外的数据存储或字符串操作。
### 4. 控制寄存器（Control Registers）

- **IP（Instruction Pointer，指令指针寄存器）：**
    - 存储下一条要执行的指令的内存地址，CPU 根据 IP 的值依次取指令执行。
- **FLAGS（标志寄存器）：**
    - 存储 CPU 运行状态和运算结果的状态信息，如进位标志（CF）、零标志（ZF）、符号标志（SF）等，用于条件判断、程序流程控制。
- **控制寄存器组（如 CR0、CR3 等）：**
    - 现代 CPU 中的特殊控制寄存器，用于开启或关闭 CPU 特殊功能，如分页、缓存控制、保护模式管理等。
## CPU是怎么利用寄存器来工作的

> 现在假设我们计算一个3 + 5 = ?

### 1. 取指令 (IP和CS寄存器)

- CPU首先查看指令寄存器(IP) 知道了下一条要执行的指令是加法
- 然后通过代码寄存器(CS), 知道了执行加法运算的指令在哪里

### 2. 取数据 (DS数据段寄存器, AX, BX通用寄存器)

- CPU把内存中的两个数字取到寄存器中
    - 把3放在AX中
    - 把5放在BX中
- DS寄存器用于告诉CPU数字3和5在内存的哪个位置

### 3. 执行计算 (ALU算数逻辑单元) 

- ALU算术逻辑单元直接访问寄存器中的数据进行计算得出计算结果是8

### 4. 存放结果 (AX)

- 计算出来的结果临时存入寄存器内

### 5. 判断运算的状态 (FLAGS标志寄存器)

- 通过这个寄存器判断运算的状态
    - 结果是否为0 (8 != 0, 所以这个时候的ZF的标志为0)
    - 是否产生进位 (不进位, CF标志为0)

### 6. 将结果返回内存 (DS数据段寄存器)

- 将AX中的计算结果返回到内存中

## 重点寄存器

### IP/PC, 程序计数寄存器

- 存放了CPU下一条要执行的指令的地址

### IR (Instruction Register) 指令寄存器

- 用于暂存当前正在执行的指令的寄存器
    - CPU从内存中取出指令以后, 会先将这条指令存放在IR寄存器中, 然后再解码并执行
    
- 能防止指令被干扰

### IR与CS代码段寄存器

- CS代码段寄存器告诉CPU指令具体在内存哪个段里, CPU再去取出放进IR中

## 总线

- 地址总线, 用于指定CPU将要操作的内存地址
- 数据总线, 用于读写内存的数据
- 控制总线, 用于发送和接受信号, 比如中断, 设备复位等信号, CPU收到信号后自然进行响应, 也需要控制总线

> CPU读写内存数据的时候, 一般需要通过下面的三个总线

- 通过 地址总线 来指定内存的地址
- 通过 控制总线控制 是读还是写命令
- 通过 数据总线 来传输数据

##  结合总线CPU执行一条命令的全过程

1. CPU读取 **程序计数器** 的值, 这个值是指令的内存地址 -> **控制单元**通过**地址总线**指定需要访问的内存地址 -> 通过内存准备数据 -> 通过**数据总线**将指令传给CPU -> 将指令数据存进**IR(指令寄存器)**中
2. **程序计数器** 自增, 表示指向下一条指令. 自增的大小由CPU的位宽决定, 如32位的CPU位宽是4字节,  PC就会自增4, 因一条指令是4个字节, 需要4个内存地址存放
3. CPU解码指令寄存器中的指令
    - 计算型指令 -> 交给逻辑运算单元
    - 存储型指令 -> 控制单元
    
## 指令的类型

> 从功能划分, 可以将指令划分为5大类

- **数据传输类型的指令**, 比如 `store/load` 是寄存器与内存间数据传输的指令, `mov`是将一个内存地址的数据移动到另一个内存地址的指令
- **运算类型的指令**, 逻辑运算和算数运算指令, 最多只能处理两个寄存器中的数据
- **跳转类型的指令**, 通过修改程序计数器的值来跳转执行指令的过程, 比如编程中常见的 if-else, switch-case, 函数调用等
- **信号类型的指令**, 比如发生中断的指令 `trap`
- **闲置类型的指令**, 比如指令`nop`, 执行后CPU会空转一个周期

## 64位CPU和32位CPU对比

> 64位的性能一定比32位高很多吗

- 64位的优势可以从两方面来看
    - 可以一次性运算超过32位的数字, 但是实际上这么大的数字运算很少发生
    - 32位的地址总线最大只能是32位, 最大寻址能力是4G, 而64位的cpu有64位,  最大寻址能力是 `2^64`, 远超于32位CPU的寻址能力
    
> 64位的软件和32位的软件之间区别是什么, 64位的操作系统能运行在32位的系统上吗, 反过来能吗

区分32位还是64位的软件, 主要考虑的是指令是64位的还是32位的
-  32位的指令在64位的机器上运行, 只需要做一套兼容机制就能实现了, 反过来就不行, 32位的寄存器存不下64位的指令

硬件的32位和64位指的是硬件的带宽, 软件的32位和64位指的是指令的位宽