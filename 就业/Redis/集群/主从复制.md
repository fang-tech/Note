# 主从复制是怎么实现的

保证高可用的核心就是**多副本构建, 冗余**, 这样才能在其中一个实例出现问题的时候, 通过其他的副本恢复服务

Redis通过主从复制来保证高可用

构建了多副本以后就需要面临以下问题

- 如何进行副本和主实例之间的数据同步
- 数据的读写是主服务器和副服务器都可以操作的吗

![主服务器和副服务器](https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png)

Redis的主从复制模式

- 只有主服务器能写数据, 其他的从服务器只能读数据
- 主服务器发生写操作的时候, 会自动将写操作同步给从服务器

## 第一次同步

通过`replicaof`(Redis5.0之前是slaveof)命令构建主服务器和从服务器之间的关系

```c
# 服务器B执行这条命令
replicaof <服务器A IP> < 服务器A Redis端口号>
```

接着服务器B就会变成服务器A的从服务器

主从服务器之间的第一次同步可以分为三步

- 第一步 : 建立链接, 协商同步
- 第二步 : 主服务器同步数据给从服务器
- 第三步 : 主服务器发送新写操作给从服务器

![](https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png)

### 建立链接, 协商同步

从服务器发送 `psync`命令给主服务器, 表示要进行数据同步

`psync {runID} {offset}`

- runID, 每个Redis服务器在启动的时候都会随机获取一个ID来标识自己, 当主从服务器第一次同步的时候, 因为不知道主服务器的runID, 所以是?
- offset, 表示复制的进度, 第一次同步, 设置为-1

主服务器收到了命令以后, 会返回`FULLRESYNC`作为响应命令 : FULLRESYNC表示采用**全量复制**的模式

这个命令同样会带上runID和offset表示主服务器的ID和主服务器的复制进度

### 主服务器同步数据给从服务器

主服务器在发送完`FULLRESYNC`以后就会执行bgsave命令生成RDB文件, 然后将文件发送给从服务器

这个进程是后台进程, 也就是不会阻塞主线程在这个过程执行写命令, 那么生成的快照和主服务器中的实际的数据就产生了偏差

为了**保证主从服务器数据的一致性, 就会将在这三个时间间隙中收到的写操作命令, 写入到replication buffer缓冲区内**

- 在主服务器生成RDB文件期间
- 在主服务器发送RDB给从服务器期间
- 从服务器加载RDB文件期间

### 主服务器发送新写操作命令给从服务器

在从服务器接收RDB文件并成功加载以后会恢复一个确认消息给从服务器

接着, 主服务器就将replication buffer中的写操作命令发送给从服务器, 从服务器执行, 这个时候主从服务器之间的数据就一致了

## 命令传播

在第一次同步以后, 主从服务器之间就会维持一个TCP长连接, 来传播命令

之后主服务器执行写命令以后, 就会将命令通过这个TCP长连接传播给从服务器, 从服务器执行

使用长连接是为了避免频繁的TCP连接和断开带来的性能开销

**基于长连接的命令传播**

## 分摊主服务器的压力

在有很多从服务器的时候, 进行全量同步的时候就会有两个问题

- 通过bgsave生成RDB文件, 主服务器会忙于执行`fork()`, 从而阻塞主服务器, 使其无法正常处理请求
- 传输RDB文件会占用主服务器的带宽, 对主服务器响应命令造成影响

解决方案 : 不让所有的从服务器都直接和主服务器交互, 创建从服务器的从服务器

![](https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png)

**让一部分从服务器交给充当经理角色的从服务器, 通过在从服务器执行replicaof就行**

## 增量复制

如果主从服务器之间的网络出现了问题等意外情况, 导致主从服务器之间无法正常通信, 而在这期间, 主服务器接受到了写操作命令, 这个时候主从服务器之间的数据就出现了不同步

在redis2.8之前, 会在重连的时候, 从服务器执行全量复制, 但是全量复制的开销太大了, 后面引入了**增量复制 : 只重新复制在断连的时候主线程执行的写操作命令**

![](https://img-blog.csdnimg.cn/img_convert/e081b470870daeb763062bb873a4477e.png)

增量复制会有三个步骤

- 在从服务器恢复网络以后, 会发送`fsync {runID} {offset}`命令给主服务器, 这个时候offset的值不是-1
- 主服务器用CONTINUE响应命令告诉从服务器接下来采用增量复制的方式同步数据
- 主服务器将主从服务器断线期间主服务器执行的写命令传播给从服务器

> 那么主服务器是怎么哪些是要发送的增量数据呢?

- repl_backlog_buffer, 是主服务器中的一个环形的缓冲区, 主从服务器断连以后, 可以从中找到差异数据
- replication offset, 标记上面的环形缓冲区的同步进度, 主从服务器都有各自自己的偏移量, 主服务器用**master_repl_offset标记自己写到的位置**, 从服务器使用slave_repl_offset标记自己读到的位置

主服务器在进行命令传播的时候, 不仅会将命令传播给从服务器, 还会将命令写入到repl_backlog_buffer中, 这个缓冲区中保存了最近传播的写命令

从服务器重新连接上主服务器以后, 会通过psync命令发送自己的复制偏移量 slave_backlog_buffer给主服务器, 主服务根据自己的master_backlog_buffer和slave_backlog_buffer进行比对, 来决定执行哪种同步操作

- 如果从服务器要读取的数据都还存储在环形缓冲区中, 就会采用增量同步的方式
- 如果从服务器要读取的数据不在环形缓冲区中, 就会采用全量同步的方式

全量复制的开销是很大的, 为了避免断连的时候发生频繁的全量复制, 尽量将repl_backlog_buffer的大小设置得大一些

repl_backlog_buffer = second \* write_size_per_second

- second是从服务器断连以后重新连接上主服务器的平均时间
- write_size_per_second是主服务器平均每秒产生的写命令数据大小

一般会设置成这样计算出来的两倍

可以在redis.conf配置文件中设置

```shell
repl-backlog-size 1mb
```