# 哨兵机制

## 为什么要有哨兵机制

在主从集群下, 如果主节点挂了就不能执行写操作, 这个时候就需要手动将从服务器切换成主服务器 `SLAVEOF NO ONE`
同时在从服务器中指定新的主服务器为主服务器, 同时还要通知上游的客户端, 将Redis的主服务器的IP切换成新的主服务器的IP
为了解决这个繁琐麻烦的过程, Redis通过哨兵机制, 用一个节点来检测主节点, 如果主节点挂了, 就选举从节点中的一个为新的主节点, 实现**主从故障转移**

## 哨兵机制是怎么工作的

哨兵节点主要做三件事

- 监控 : 哨兵节点节点是怎么监控节点的, 是怎么判断主节点已经故障了
- 选主 : 哨兵节点是根据什么规则选择一个新的节点作为主节点的
- 通知 : 哨兵节点是怎么把新的主节点的相关信息通知给从节点和客户端的

### 监控

> 怎么监控节点的?

哨兵节点会每隔1s向所有的主从节点发送PING命令, 节点收到PING命令以后会返回一个响应给哨兵节点

![](https://img-blog.csdnimg.cn/26f88373d8454682b9e0c1d4fd1611b4.png)

如果主从节点不响应的时间超过了`down-after-milliseconds`, 单位是毫秒, 这个哨兵节点就会将节点标记为 **\[主观下线]**
有主观下线也有客观下线, 之所以针对主节点设计主观下线和客观下线两种状态, 是因为可能主节点不响应是主节点的系统压力太大了或者网络发生了阻塞, 并不是主节点发生了阻塞
客观下线需要多个哨兵节点一起判断, (哨兵往往是集群部署的, 最少有3台), 通过多个哨兵一起判断, 能有效避免**单个哨兵节点因为自己的网络状况而误判主节点故障**
在哨兵节点标记为主观下线以后, 会向其他的哨兵发送 `is-master-down-by-addr`命令, 其他的哨兵收到这个命令以后, 就会根据自己和主节点之间的连接状况投票, 如果**赞成票的数量超过quorum的配置以后, 就会判断主节点已经客观下线**, 然后哨兵节点就要从从节点之中选择下一个主节点

### 由哪个哨兵节点来进行故障转移?

在有节点判断主从节点主观下线以后,  再通过哨兵集群投票确认主节点已经客观下线以后, 接下来就是选出来一个哨兵节点来进行故障转移, 即选出来一个leader

在投票之前哪个哨兵节点判断的节点是客观下线的节点, 哪个节点就是leader的候选者, 候选者会向其他的实例发送命令, 表示自己想成为leader来执行主从切换, 并让其他所有的哨兵节点对他进行投票, 如果满足以下两个条件就能成为leader

- 拿到半数以上的赞成票
- 得票数大于等于quorum中的值

> 为什么哨兵的节点数量最少为3个

- 这是能完成哨兵判断节点是客观下线的最少节点数量
- 哨兵节点能完成选举出来一个Leader的最少节点数量

**quorum的值建议设置为哨兵数量 / 2 + 1**

## 主从故障切换的过程是怎么样的

1. 选择出来一个从节点作为主节点
2. 让其他的从节点成为新主节点的从节点
3. 通知客户端主节点已经更换了
4. 继续监视原来的故障的旧主节点, 如果旧主节点恢复正常了, 就让旧的主节点成为新主节点的从节点

### 1. 选出新的主节点

选择出来一个新的主节点, 然后哨兵节点下向其发送`SLAVEOF NO ONE`将其切换成主节点

> 那么我们该怎么选出来新的主节点呢?

首先我们要排除那些网络状况不好的节点, 这些节点很可能还会发生断连, 这样就会导致频繁的主从切换, 再根据三轮的考察选出来新的主节点

> 怎么判断节点的网络状况不好呢?

Redis中有个down-after-milliseconds \* 10的配置项, 如果主从节点之间断连的时间超过了这个配置的时间, 就会视做认为主从节点已经断连了, 如果有一个节点的断连的次数超过了10次, 就会视作是网络不好的节点

#### 优先级最高的节点胜出

在Redis中有个slave-priority的配置, 能配置节点的优先级, 因为不同的Redis实例对应的物理配置可能是不一样的, 如果有一个Redis的实例的物理机中的物理内存更多, 这个时候我们就可以配置它的优先级更高, 从而能让它在发生主从故障切换的时候更容易称为新的主节点

#### 复制进度最最快的节点胜出

如果有两个节点的优先级是一样的, 这个时候就会进入到下一轮的考察 : 比较两个节点的之间的复制进度

也就是比较两个节点的slave_repl_offset的值, 谁的值最接近master_repl_offset的值, 谁的复制进度就是最靠前的, 就选为新的主节点

#### ID号最小的胜出

如果还有多个节点之间的复制进度都是一样的, 这个时候就会选出来ID号最小的节点作为新的主节点

在选举出来新的主节点, 并且发送了`SLAVEOF NO ONE`的命令以后, 会以每秒一次的频率向其发送`INFO`命令来查看其切换成主节点的进度(原本是每十秒发送一次INFO), 并观察回复中的角色信息, 当得知角色信息由原本的slave变成了master, 哨兵节点就知道节点已经升级成了主节点

### 2. 将从节点指向新的主节点

新的主节点出现以后, 哨兵节点会向其他的从节点发送` SLAVEOF <new-ip> <new-port>`的命令来让从节点指向新的主节点

### 3. 通知客户端主节点已经更换

完成主从切换的工作以后, 就会通过**Redis的发布者/订阅者机制来实现通知客户端**

![频道](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E5%93%A8%E5%85%B5%E9%A2%91%E9%81%93.webp)

哨兵节点会向`+switch-master`频道发布新的主节点的IP和端口信息, 然后客户端就能使用新的IP和端口来进行通信了

### 4. 将旧主节点转化成从节点

哨兵节点还是会继续监视原来的旧的主节点, 当其恢复通信的时候, 就会将其转化成新主节点的从节点

## 哨兵集群的组成方式

向一个哨兵集群中添加哨兵, 只需要在哨兵节点中发送命令

```shell
sentinel monitor <master-name> <ip> <redis-port> <quorum>
```

只需要设置主节点的名字, IP, 端口以及quorum的值, 那么节点之间是怎么相互发现的呢

Redis的哨兵节点之间是通过**Redis的发布者/订阅者机制来相互发现的**

在主从集群中, 主节点上有一个`__sentinem__:hello`频道, 不同的哨兵节点之间就是通过这个频道来相互发现的

哨兵节点都订阅了这个频道, 在新的哨兵节点加入以后, 就会将自己的IP和端口号发布到这个频道上, 其他的哨兵节点就能从频道上直接获取哨兵节点的IP和端口号

> 哨兵节点是怎么知道从节点的信息的

哨兵节点每10秒会向主节点发送`INOF`命令, 主节点接受到这个命令以后, 会将从节点的列表发送给哨兵节点, 哨兵就能通过列表中的从节点的信息, 和每个从节点之间构建连接



