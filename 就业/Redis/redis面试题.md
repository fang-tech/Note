# Redis面试题

## 为什么使用Redis

### 为什么选用Redis作为MySQL数据库的缓存?

## Redis过期删除与缓存淘汰策略

### Redis使用的过期删除策略是什么?

Redis中可以为key设置过期时间, Redis中有单独的一张表用于记录每个key的过期时间

对于删除操作, Redis中有 **懒惰删除** 和 **定期删除** 两种策略

- **懒惰删除** : Redis会在下一次使用到这个key的时候, 先去检查这个key是不是再过期时间表中, 如果在并且已经过期了, 就会将这个key删除, 也就是从内存中释放
  - 优点 : 对CPU时间友好, 占用CPU的时间更少
  - 缺点 : 对缓存不友好, 没有被使用到的key会一直占用内存, 即使它已经过期了
- **定期删除** : 为了补足上面懒惰删除中某些没有被使用的过期key会一直占用内存的问题, Redis还有定期删除的设置, Redis会定期抽取一定数量的key, 并检查它们是不是过期了, 过期了就删除. 如果(过期的key / 所有检查的key) > 25%, 就会立马开启下一轮检查, 因为这个时候说明redis中有很多过期的key. 否则则等待下一轮检查. 同时为了避免这个删除循环过度, 导致线程卡死, redis中对于每一轮还有时间限制, 如果超过最大时间(默认25ms), 也会退出等待下一轮检查
  - 优点 : 能清理过期的且使用频率低的key, 对内存友好, 同时最大时间的设置, 也能限制这个操作占用过多的cpu时间
  - 缺点 : 执行的频率和时间难以把握

### Redis持久时, 对过期键会如何处理?

对于RDB(Redis Database)文件

- **RDB文件生成阶段** : 生成的时候会对key进行过期检查, 过期键不会被写入
- **RDB文件加载阶段** : 需要从主节点和从节点分情况讨论
  - **主节点** : 会进行键的过期检查, 如果键过期了, 就不会加载进Redis中
  - **从节点** : 不会检查, 会将RDB文件中的内容全部重新加载进Redis中, 但是主从节点进行数据同步时候, 从服务器中的数据会被清空, 所以从节点中的过期键也不会造成什么影响

对于AOF(Append Only)文件

- **AOF文件生成阶段 :** 如果持久化的时候, 数据库中的某个过期键还没有被删除, 就会保留这个键, 等到过期键被删除的时候, 会显式地追加一条DEL删除指令.
- **AOF文件重写阶段** : 执行AOF重写的时候, 会对Redis中键进行检查, 已经过期的键不会保存到重写后的AOF文件



### 主从模式下, Redis怎么处理过期键

从服务器不会对过期键做任何处理, 而是在主服务器会对键进行过期检查, 发现键是过期以后, 会在AOF文件中追加一条DEL指令, 同步到所有的从库, 从库通过执行这条DEL指令来删除过期键

### 内存淘汰策略有几种

在内存满了以后, 会触发Redis的内存淘汰策略, 可以通过设置redis的maxmemory参数设置
内存淘汰策略可以大致分为 **不进行数据淘汰策略**, **进行数据淘汰策略**两类

- **不进行数据淘汰策略** : 就是简单的在内存满了(超过设置的最大内存)以后, 不淘汰任何数据, 不再提供服务, 直接返回错误
- **进行数据淘汰的策略** : 又可以再分成两类, 全局淘汰和只在设置了过期时间的键中进行淘汰
  - **全局淘汰** : `allkeys_random` : 全局随机淘汰键, `allkeys_lru` : 全局LRU淘汰, `allkeys_lfu` : 淘汰整个键值中最少使用的键
  - **只在设置了过期时间的键中进行淘汰** : `volatile_random` : 随机淘汰设置了过期时间的键, `volatile_lru` : 淘汰最久未被使用的键, `volatile_lfu` : 淘汰使用次数最少的键, `volatile_ttl` : 淘汰过期时间更早的键

### Redis中的LRU与LFU

> LRU : Least Recently Used : **最近最少使用**

LRU最大的问题是需要维护一个所有数据对象大链表, 以及每次在访问数据项的时候都需要移动链表项, 这两个操作的开销都很大
所以在Redis中的LRU是一种 **近似LRU**, 从而减小LRU算法的开销

- 为每个redis数据对象添加一个**时间戳**属性, 用于记录数据的, 记录数据 **最后一次访问时间**
- Redis在执行缓存淘汰策略的时候, 通过 **随机采样的方式淘汰数据**, **每次随机抽取5个数据(可以配置), 然后淘汰掉其中的时间戳最久远的一个数据项**
但是LRU无法解决 **缓存污染** 的问题

> LFU : Least Frequently Used : **最近最不常用**

Redis记录每个数据项的使用次数

> lru : 24bit

在LRU算法中, 这个24bit的数据记录最近一次访问的时间戳
在LFU算法中, 高16位存储最近访问时间, 低8位存储访问次数

在redis中, 同一时间内, 只会使用一种方式解释lru属性, 在运行期间一般不会随意切换淘汰策略

- 如果从LRU -> LFU : 会将redis对象的lru值初始化(一般是5)
- 如果从LFU  -> LRU : 会用新的解释策略解释lru的值

### 