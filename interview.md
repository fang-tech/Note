# 面试问题积累

## 链表

### 描述链表的数据结构

分为指针域和数据域, 指针域内存有下一个节点的地址, 数据域包含链表承载的数据

- 单向链表的指针域指向下一个节点
- 双向链表的指针域同时有前驱和后继
- 循环链表的指针域最后一个节点的指针指向头节点

### LinkedList使用的是单向链表还是双向链表

双向不循环链表

### 链表中数据的插入, 删除, 获取元素, 时间复杂度是多少

- 数据的插入 :
  - 已知节点位置时 : $O(1)$
  - 需要查找位置时 : $O(n)$
- 数据的删除 :
  - 已知节点位置时 : $O(1)$ (双向链表, 单向仍为$O(n)$
  - 需要查找位置时 : $O(n)$
- 获取元素 :
  - 平均时间$2/n$
  - 时间复杂度$O(n)$

### 什么场景下使用链表更合适

- 数据量不确定的时候, 需要动态扩容
- 不需要频繁地访问元素
- 需要频繁地在任意位置插入元素

## 数组

### 数据结构中哪些是线性表数据结构

- 链表, 栈, 队列, 数组

### 数组的元素删除和获取, 时间复杂度是多少

- 删除 : $O(n)$, 需要移动删除元素后面的元素向前一格
- 获取 : $O(1)$, 通过索引直接获取

### ArrayList中默认的初始化长度是多少

- 10

### ArrayList 中扩容的范围是多大一次？

- newCapacity = oldCapacity + (oldCapacity >> 1), 每次扩容一半, 以平衡频繁扩容和内存浪费的问题

### 如何完成扩容的, System.arraycopy 各个入参的作用是什么？

- 如何完成扩容的 : 如果mincapacity > elemData.length的时候, 说明现在数组满了, newCapacity = oldCapacity + (oldCapacity >> 1), 同时考虑size被初始赋值的情况, 保证了newCapacity不会小于最小扩容大小minCapacity, 再将数据移到新的容量为newCapacity的数组中

- 传入的各个参数的作用 :
  - public static void arraycopy(Object src,	=> 目标数组
                                 int srcPos, 						=> 拷贝到目标数组的哪个位置, 起始位置
                                 Object dest,						=> 原始数组
                                 int destPos,						=> 从原始数组的哪个位置开始拷贝, 起始位置
                                 int length)							=> 拷贝多少个元素, 迁移量	