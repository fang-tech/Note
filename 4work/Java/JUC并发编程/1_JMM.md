# Java内存模型

## 什么是JMM

JMM指的是Java Memory Model, 是Java虚拟机规范中定义的一组规则, 用于规范多线程环境下的内存访问操作

- **从通信的角度来看**, JMM决定了一个线程对共享变量的写入什么时候对另一个线程可见
- **从抽象的角度来看**, JMM定义了线程和主内存之间的抽象关系 :
  -  线程之间共享变量存储在主内存
  - 每个线程都有一个私有的本地内存
  - 本地内存中存储了该线程以读/写共享变量的副本
- **关于本地内存**
  - 本地内存是JMM的一个抽象概念, 并不是真实存在的. 
  - 它涵盖了缓存, 写寄存器以及其他的硬件和编译器优化导致的线程中实际读写共享变量的时候, 并不是直接读写主存中的共享变量
- **JMM的目的**
  - JMM通过控制主内存与每个线程的本地内存之间的交互, 来为Java程序员提供内存可见性, 操作原子性, 有序性的保证
  - 为程序员提供跨平台的内存可见性保证
  - 为程序员屏蔽各种硬件架构和操作系统之间的差异
- **JMM解决的核心问题**
  - 可见性: 保证一个线程修改的数据对其他线程可见
    - 通过内存屏障保证修改后的值能立即被其他线程看到
  - 原子性: 保证操作不会被线程调度机制打断
    - 主要通过synvhronized和各种锁机制实现
    - JMM本身只保证基本的读取和赋值操作的原子性
  - 有序性: 保证程序执行的顺序符合预期
    - 通过happens-before规则定义操作之间的偏序关系
    - 通过内存屏障禁止特定类型的指令重排序

## 可见性

### happens-before

JMM向程序员提供了happens-before规则, 阐述了操作之间的内存可见性, 如果一个操作执行的结果需要对另一个操作可见, 两个操作之间必须存在happens-bofore规则, 这两个规则可以是同一个线程下的, 也可以是多个线程下的, 和程序员相关的规则如下:

- 程序顺序规则: 一个线程中的每个操作, happens-before于该线程中的任意后续操作
- 监视器锁规则: 对于一个监视器锁的解锁, happens-before于随后对于这个监视器锁的加锁
- volatile变量规则: 对于一个volatile字段的写, happens-before于任意后续对这个volatile字段的读
- 传递性: 如果A happens-before B, B happens-before C, 那么A happens-before C

**两个操作之间如果存在happens-before关系, 并不意味着前一个操作一定先于后一个操作执行, happens-before只保证前一个操作的结果对后一个操作可见**

通过happens-before规则, 能让Java程序员不需要关注硬件架构和操作系统, 就能知道怎么样保证可见性

## 重排序

什么时候会发生指令重排序? 指令重排序在多线程情境下会带来什么问题? 回答这个问题是理解JMM为什么需要提供happens-before规则, 以及怎么提供的关键

### 数据依赖性

如果两个操作访问同一个变量, 其中有一个操作是写操作, 此时两个操作之间存在数据依赖性

分为三种

- 写后读 : a=1; b=a;
- 写后写 : a=1; a=2;
- 读后写 : b=a; a=1

上面三种操作, 只要重排序两个操作之间的顺序, 程序的执行结果就会造成改变

编译器和处理器可能会对操作重排序, 但是它们两个在重排序的时候都会遵守数据依赖性, 不会改变存在数据依赖性的两个操作的执行顺序

这里的数据依赖性只针对单个处理器中的指令序列和单个线程中执行的操作, 不同处理器之间和不同线程之间的数据依赖心不被处理器和编译器考虑

### as-if-serial语义

as-if-serial语义的意思是 : **不管怎么重排序, 单线程程序的执行结果不能被改变**

遵守as-if-serial语义的编译器和runtime和处理器, 共同为程序员提供了一种幻觉 : 程序是严格按照顺序执行的, 这个语义使得单线程程序中不需要担心指令重排带来的干扰和内存可见性问题

### 重排序对多线程的影响

```java
class ReorderExample {
    int a = 0;
    boolean flag = false;

    public void writer() { // Thread A
        a = 1;                   //1
        flag = true;             //2
    }

    public void reader() { // Thread B
        if (flag) {                //3
            int i =  a * a;        //4
            ……
        }
    }
}
```

线程A执行writer函数, 线程B执行reader()函数, 我们期望的执行顺序是

1. a = 1
2. flag = true
3. if (flag)
4. i = a \* a

我们想通过flag标记变量保证如果执行了操作4一定是已经执行了操作1

但是线程B在执行操作4的时候能看到线程A操作1对于共享变量的写入吗?

**不一定能看到**

操作1和操作2之间没有数据依赖性, 可能做重排序, 程序执行的时候, 会出现线程A首先标记flag = true, 然后线程B读这个变量, 然后执行i = a \* a, 最后线程A执行A = 1, 多线程的语义就被破坏掉了

![img](https://pdai.tech/images/jvm/java-jmm-8.png)

操作3和操作4, 通过猜测执行机制, 实质上也可以对操作做重排序

- 操作3和操作4之间存在控制依赖关系, 当代码中存在控制依赖性的时候, 会影响程序的并行度. 这个时候编译器和处理器会采用猜测执行来克服相关性对并行度的影响

![img](https://pdai.tech/images/jvm/java-jmm-9.png)

这个时候多线程程序的语义就被重排序破坏掉了

## 顺序一致性

### 数据竞争和顺序一致性保证

当程序没有正确同步的时候, 就会存在数据竞争, JMM对数据竞争的定义

- 在一个线程中写一个变量
- 在另一个线程中读同一个变量
- 而且写和读没有通过同步来排序

JMM对正确同步的多线程程序的内存一致性做了如下保证

- 如果程序是正确同步的, 程序的执行将具有顺序一致性, 即程序的执行结果和该程序在顺序一致性模型中的执行结果是一样的

### 顺序一致性模型

顺序一致性模型是一个理论参考模型, 为程序员提供了极强的内存可见性保证

- 一个线程中的所有操作必须按照程序的顺序执行
- (不管程序是否同步) 所有线程都只能看到单一的操作执行顺序
- 每个操作都是原子执行且立刻对所有线程可见

假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1->A2->A3。B 线程也有三个操作，它们在程序中的顺序是：B1->B2->B3。

假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：

![img](https://pdai.tech/images/jvm/java-jmm-11.png)

现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：

![img](https://pdai.tech/images/jvm/java-jmm-12.png)

未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1->A1->A2->B2->A3->B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。

但是JMM对未同步程序没有做这个保证, 未同步程序在JMM中不但整体的执行顺序使无序的, 而且所有线程看到的操作执行顺序也可能是不一致的. 比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见

### 同步程序的顺序一致性效果

在顺序一致性模型中, 所有操作完全按照程序的顺序串行执行, 但是在JMM中, 临界区内的代码可以重排序

虽然线程A在临界区内做了重排序, 但是由于锁的互斥执行的特性, 线程B根本无法观察到A中的重排序, 所以没有改变程序执行的结果

**JMM在具体实现上的基本方针 : 在不改变(正确同步)程序执行结果的前提下, 尽可能未编译器和处理器的优化提供便利**

### 未同步程序的执行特性

未同步程序在JMM中的执行, 整体上是无序的, 其执行结果也无法预知

- 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。

- 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。

- JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。

在一些 32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 / 写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。

## 总结

### 处理器的内存模型

顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。

根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：

- 放松程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。
- 在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。
- 在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。

注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。

下面的表格展示了常见处理器内存模型的细节特征：

| 内存模型名称 | 对应的处理器  | Store-Load 重排序 | Store-Store 重排序 | Load-Load 和 Load-Store 重排序 | 可以更早读取到其它处理器的写 | 可以更早读取到当前处理器的写 |
| ------------ | ------------- | ----------------- | ------------------ | ------------------------------ | ---------------------------- | ---------------------------- |
| TSO          | sparc-TSO X64 | Y                 |                    |                                |                              | Y                            |
| PSO          | sparc-PSO     | Y                 | Y                  |                                |                              | Y                            |
| RMO          | ia64          | Y                 | Y                  | Y                              |                              | Y                            |
| PowerPC      | PowerPC       | Y                 | Y                  | Y                              | Y                            | Y                            |

在这个表格中，我们可以看到所有处理器内存模型都允许写 - 读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。

上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。

由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图

![img](https://pdai.tech/images/jvm/java-jmm-x01.png)

JMM屏蔽了不同处理器内存模型之间的差异, 它在不同的处理器平台上为java程序员呈现了一个一致的内存模型

### JMM，处理器内存模型与顺序一致性内存模型之间的关系

JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：

![img](https://pdai.tech/images/jvm/java-jmm-x02.png)

从上图我们可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。

### JMM 的设计

从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：

- 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。
- 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。

由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看 JSR-133 是如何实现这一目标的。

为了具体说明，请看前面提到过的计算圆面积的示例代码：

```java
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C
```

上面计算圆的面积的示例代码存在三个 happens- before 关系：

- A happens- before B；
- B happens- before C；
- A happens- before C；

由于 A happens- before B，happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before 要求禁止的重排序分为了下面两类：

- 会改变程序执行结果的重排序。
- 不会改变程序执行结果的重排序。

JMM 对这两种不同性质的重排序，采取了不同的策略：

- 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。
- 对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。

下面是 JMM 的设计示意图：

![img](https://pdai.tech/images/jvm/java-jmm-x03.png)

从上图可以看出两点：

- JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens- before B）。
- JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。

### JMM 的内存可见性保证

Java 程序的内存可见性保证按程序类型可以分为下列三类：

- 单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
- 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- 未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）
