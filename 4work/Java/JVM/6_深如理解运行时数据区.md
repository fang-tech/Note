# JVM运行时数据区

## 程序计数器

每个线程都有自己的**私有**的PC(Program Counter), 

**线程执行的是非本地方法, PC指向下一条将要运行的指令**(准确来说是, 在执行指令的时候, PC指向下一条将要运行的指令, 在其他任意时刻, 指向的是下一条要运行的指令)

**线程执行的是本地方法的时候, PC的值是undefined**, 因为本地方法不是在JVM中运行的, 往往是通过C/C++实现

## 虚拟机栈

这个在深入理解栈帧里面有详细说明

## 本地方法栈

区别于虚拟机栈, 本地方法栈为虚拟机使用到的本地方法服务

## 堆

**堆区是所有线程共享的一块区域, 用来存储对象(静态变量在堆中)**

Java中的几乎所有对象都是在堆中存储的

> 为什么不是所有?

现代JVM默认开启逃逸分析, 如果某些方法中的对象或者引用没有在方法之外被使用过(也就是没有逃逸), 这个时候就会将对象存储在虚拟机栈中的局部变量空间

堆区最容易出现的错误就是OOM(Out of Memory), 有两种表现形式

- `OutOfMemoryError : GC Overhead Limit Exceed`: 当JVM花太长时间执行垃圾回收还没有回收到多少内存的时候就会发生
- `java.lang.OutOfMemoryError: Java heap space`: 堆中的空间不足够申请的新的对象, 和配置的虚拟机的堆内存有关

### 字符串常量池

在堆区中, 在jdk1.6的时候在永久代中, 从1.7开始就被迁移到了堆区

### 垃圾回收

为了进行高效的垃圾回收, 虚拟机把堆内存在逻辑上分成三块 (**分代的唯一理由就是优化GC性能**)

- 新生代 : 新对象和没有达到一定年龄的对象都在新生代
- 老年代 : 被长时间使用的对象, 老年代的内存空间应该比年轻代要大
- 元空间 : 像一些方法中的操作临时对象等

### 新生代

创建新对象的时候会被分配到年轻代内存区域, 直到这个区域的空间被占满或者达到某个阈值, 就会执行垃圾收集. 这种垃圾收集被称作 **Minor GC**.

年轻代被分成了三个部分, 伊甸园(Eden Memory), 两个幸村区(Survivor Memory, 被称为from/to或s0/s1). 默认比例是8:1:1

- 大多数新创建的对象都在Eden内存空间
- 当Eden空间被对象填充时, 会执行Minor GC, 并将所有的幸存者对象移动到另一个幸存者空间
- Minor GC检查幸存者对象, 并将它们移动到另一个幸存者空间, 所以总是有一个幸存者空间是空的
- 如果幸存者空间满了, 无法容纳从Eden区存活下来的对象, 这些存活的对象会直接被提升到老年代, 即使还没有达到晋升需要的年龄, 如果进一步老年代空间也不能容纳, 就会触发Full GC, 导致整个Java堆内存都被回收
- 经过多次GC循环后存活下来的对象被移动到老年代, 通常这是通过设置年轻一代对象的阈值来是实现的, 然后它们才有资格提升到老年代

### 老年代

旧的一代内存包含那些经过许多轮小型GC后仍然存活的对象, 通常垃圾收集是在老年代内存满的时候执行的, 老年代垃圾收集被称为 **主GC**(Major GC)

大对象直接进入到老年代(需要大量连续内存的对象), 能避免在Eden区和Survivor区之间发生大量的内存拷贝

![img](https://pdai.tech/images/jvm/jvm/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg)

### 对象在堆内的生命周期

1. 当创建一个对象的时候, 对象会被优先分配到新生代的Eden区, 此时JVM会给对象定义一个对象年轻计数器 (`-XX:MaxTenuringThreshold`)
2. 当Eden空间不足的时候, JVM将会执行新生代的垃圾回收
   1. JVM会把存货的对象转移到Survivor中, 并对象年龄+1
   2. 对象在Survivor中同样也会经历Minor GC, 每经历一次以后年龄+1
3. 年龄达到15次以后(默认标志)就会被分配到老年代
4. 当分配的对象超过了 `-XX:PetenureSizeThreshold`, 对象会**直接被分配到老年代**, 也就是大对象

## 方法区(永久代/元空间)

永久代和元空间都是对于方法区的一个实现

永久代是在JVM内存中的, 元空间直接使用的是操作系统的内存而不是JVM内存

在元空间数据增长的时候, 会从操作系统申请内存, 也就是在这一步, 元空间增长也会导致操作系统层面的OOM

### 内部结构

**方法区用于存储已被虚拟机加载的类型信息, 常量, 即时编译器编译后的代码缓存等**

.class文件中有常量池, 在运行的时候, 将class文件中的常量池加载到内存中

#### 类型信息

对于每个加载的类型, JVM都必须在方法区存储以下类型信息

- 类型的全限定类名
- 类型的直接父类全限定类名
- 类型的修饰符
- 类型直接接口的一个有序列表

#### 字段信息

- JVM必须在方法区中保存类型的所有字段的相关信息和声明顺序
- 字段的相关信息 : 字段名称, 字段类型, 字段的修饰符(这里也能从Java类文件结构看到)

#### 方法信息

- 方法名称
- 方法参数的数量和类型
- 方法的返回类型
- 方法的修饰符
- 方法的字符码, 操作数栈, 局部变量表及大小
- 异常表

