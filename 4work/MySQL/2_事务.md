# 事务

## 事务有哪些特性

- 原子性: 一个事务中的所有操作一起成功, 一起失败
- 一致性: 事务操作前后, 数据满足完整性约束, 简单来说就是在并发场景下保证数据的一致性
- 隔离性: 数据库允许多个并发事务同时对数据进行读写, 隔离性防止因为事务的交叉执行导致的数据不一致, 每个事务有自己的隔离的数据空间
- 持久性: 事务结束以后, 对数据的修改就是永久的

InnoDB通过什么来保证这四个特性呢?

- 持久性是通过 redo log来保证的
- 原子性通过 undo log来保证
- 隔离性通过MVCC或者锁机制来保证的
- 一致性通过上面三者来共同保证

## 并行事务导致的问题

MySQL在处理并行事务的时候会出现三个问题

- 脏读: 一个事务读到了另一个**未提交事务修改**的数据, 就出现了脏读
- 不可重复度读: 在一个事务内, 对于**同一数据**多次读, 读出来的**结果不同**
- 幻读: 在一个事务内, 两次读到的**结果集不同**(比如这次读到表中有5条数据, 下次读到有6条数据)

## 事务的隔离级别

事务的隔离级别一一对于对于上面的并行事务三大问题的解决, 同时隔离级别越高, 性能效率越低

- 读未提交: 一个事务没有提交的时候, 它做的修改就能被其他事务看见 (脏读, 不可重复读, 幻读)
- 读提交: 一个事务提交以后, 它的修改才能被其他事务看到 (不可重复读, 幻读)
- 可重复读: 一个事务执行过程中看到的数据, 一直跟这个事务启动的时候看到的数据一致, 是**InnoDB引擎默认隔离级别**(幻读)
- 串行化: 对记录加上读写锁, 实现事务之间的串行化()

**MySQL在可重复读隔离级别下, 可以很大程度避免幻读现象的发生**

## Read View与MVCC

###  Read View中的四个字段

- creator_trx_id: 创建该Read View的事务的事务id
- m_ids: 创建Read View的时候,  当前数据库中"活跃且未提交"的事务id列表
- min_trx_id: 创建Read View时当前数据库中活跃且未提交的事务id中最小的事务id
- max_trx_id: 创建Read View时当前数据库中给下一个事务的id值, 也就是max(m_ids) + 1

### 聚簇索引记录中的两个隐藏列

- trx_id: 当一个事务对某个聚簇索引记录进行改动的时候, 就会将该事务的id记录在这个隐藏列中
- roll_pointer: 每次对某条聚簇索引改动的时候, 都会把旧版本的记录写入到undo log中. 这个隐藏列是个指针, 指向上一个旧版本记录, 通过它能找到修改前的记录(这样递归下去我们就能找到每个版本的记录)

### 这两者是怎么共同工作实现MVCC的

创建Read View以后, 可以将记录中的trx_id分成三种情况

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png)

- trx_id < min_trx_id: 这个时候说明这个数据版本是在Read View前已经提交过的事务生成的, 数据对当前事务**可见**
- min_trx_id  \<= trx_id < max_trx_id: 说明这个数据版本是在Read View前创建, 并且那个时刻没有提交的事务修改的, 但是不知道现在该事务有没有提交, 所以需要通过m_ids额外判断
  - 如果该trx_id存在于m_ids中, 说明事务还没有提交, 这个时候该版本的记录就对当前事务**不可见**
  - 如果该trx_id不存在于m_ids中, 说明事务已经被提交了, 该版本对当前事务**可见**
- trx_id >= mar_trx_id: 说明这个数据版本是在Read View创建以后才启动的事务, 该版本对当前事务不可见