# MySQL索引

## 为什么使用B+树作为索引的数据结构

而考虑索引的数据结构的核心考量之二就是

- 能在尽可能的磁盘I/O中完成查询操作
- 要能高效地查询某一个记录, 并且支持范围操作

这样的查找问题, 最直观的第一想法是使用二叉搜索树

但是二叉搜索树有链化的风险, 接下来的选择就是AVL树和红黑树, 这样是解决了平衡问题, 但是使用二叉平衡树, 每进入到下一层我们都需要进行一次磁盘的I/O, 所以我们需要尽可能矮胖的数据结构

于是我们看向了B树, B树是一个多叉树, 每一层能记录更多的节点, 同样的节点数量, B树更加地矮胖

但是B树的每个节点都包含了索引+数据, 但是实际上在查找到目标节点之前, 我们读取到的数据实际上是没有用的, 这样会有多余的磁盘I/O, 最终我们对B树做了一个升级, 就是B+树

我们将所有的数据都放在B+树的叶子节点上, 所有的非叶子节点只起到一个索引的作用, 通过这样的设计, 我们得到了一颗"矮胖"的搜索树, 并且搜索树的非叶子节点中只有索引数据, 同时B+树的叶子节点之间使用双向链表连接起来, 原生支持范围搜索.

最终通过B+树, 我们满足了上述的两个核心考量

## 聚簇索引和二级索引

- 聚簇索引的叶子节点存放的是实际数据, 所有的完整的用户记录都存放在聚簇索引的叶子节点
- 二级索引的叶子节点存放的是主键值

InnoDB在创建聚簇索引的时候选用的列按照以下顺序

- 如果指定了主键, 就使用主键作为聚簇索引的索引键
- 如果没有主键, 就选择第一个不包含NULL值唯一列作为聚簇索引的索引键
- 上面两个都没有的情况下, 就会自动生成一个隐式自增ID列作为聚簇索引的索引键

**如果某个查询语句使用了二级索引, 但是查询的数据不是主键值的时候, 在二级索引找到主键值以后, 需要去聚簇索引中获取数据行, 这个过程就叫回表. 不过当查询的数据是主键值的时候, 在二级索引中就能找到了, 就不用去聚簇索引中查找, 这个过程就叫索引覆盖**

## 什么时候需要分库分表了?

这个问题其实很明显最后是落在B+的层高在某个行数的时候会增加一层, 最后导致查询效率猛然降低

首先我们得分析一个B+树的非叶子节点能存储多少数据, 也就是多少索引

每个B+树的节点都是一个MySQL的数据页, 每个数据页固定`16KB`的大小, 除去其中的文件头, 页头, 校验信息等元信息, 最后可用的能存放数据的空间大概是`15KB`. 主键假设是Bigint(8byte), 页号是固定的(4Byte), 一个索引数据的大小就是12byte

最后一个B+树的节点能存放15 \* 1024 / 12 = 1280行索引

叶子节点和非叶子节点的结构是一样的, 能存放数据的空间都是15KB

我们假设每行数据的大小是Y, 则一个叶子节点能放15 \* 1024 /  Y行数据

设层高是z, 最后存放的行数是X = 1280^z \* 15 \* 1024 /  Y

在z = 3, Y = 1KB的时候, X = 2.45kw

在z = 3, Y = 5KB的时候, X = 500w

所以需要分库分表的行数需要根据每行的具体大小来得出, 一般在z > 3以后就要进行分库分表了, 没增加一层就会导致磁盘I/O的次数增加1次

**同时当单表数据库达到某个量级的上限以后, 导致内存无法存储其索引, 使得之后SQL查询会产生磁盘IO, 从而导致性能下降**

## 索引失效的原因

查询条件用上了索引列, 查询过程并不是一定会用上索引

### 使用like关键字左或者左右模糊匹配无法走索引

也就是使用这样的语句查询的时候

```sql
select * from t_user where name like %xx(or %xx%)
```

**因为索引B+树是按照索引值有序排序的, 只能根据前缀来比较**

如果使用左/左右模糊匹配, 查询结果的前缀会发生变化, 就不知道从哪个索引值开始比较了, 这个时候通过全表扫描的方式来查询

### 对索引使用函数

也就是

```mysql
select * from t_user where length(name) = 6;
```

这样的语句执行的时候, 索引会失效

原因也很简单, MySQL建立的索引中保存的是索引字段的原始值, 而不是经过函数计算后的值

但是MySQL 8.0开始, 增加了函数索引, 可以针对函数计算后的值建立一个索引

```mysql
alter table t_user add key idx_name_length ((length(name)));
```

执行了这个语句以后, 再执行上面的语句就能走索引了

### 对索引进行表达式计算

```mysql
select * from t_user where id + 1 = 10;
```

理由和上面对索引使用函数一样, MySQL保存的是索引字段的原始值, 而不是表达式计算以后的值

但是

```mysql
select * from t_user where id = 10 - 1;
```

这样的语句是能正常生效的

### 对索引隐式类型转换

phone字段是varchar类型

```mysql
select * from t_user where phone = 130001;
```

这个时候会全表查询, 因为再MySQL中在等式两边分别是varchar和int类型的时候, 会将字符串类型转换成int类型

这个语句等同于

```mysql
select * from t_user where CAST(phone AS signed int) = 130001;
```

这个时候就是第二种情况, 对索引使用函数的情况了

但是

```mysql
select * from t_user where id = '1';
```

这样的语句, 因为右边是被转化了的, 所以是能正常走索引的

### 联合索引非最左匹配

多个普通字段组合在一起创建的索引就叫做联合索引

创建联合索引的时候, 需要注意索引的顺序 (a,b,c)和(c,b,a)在使用的时候存在差别

联合索引要能正常使用需要遵循**最左匹配原则** : 按照最左优先的方式进行索引的匹配

如果联合索引是(a,b,c)时候

- where a = 1
- where a = 1 and b = 2
- where a = 1 and b = 2 and c = 3

这三个语句就能正常使用联合索引

但是像

- where b = 2
- where b = 2 and c = 1
- where c = 2

这样的语句就没法走联合索引

这样的原因是, 在联合索引中, 数据排序的顺序是: 先按照索引第一列排序, 第一列数据相同的时候才会按照第二列排序, 以此类推

所以如果我们只使用了第二列搜索, 这个时候, 没办法比较第一列数据, 这个时候索引就失效了

> 对于where a = 1 and c = 2这样的查询语句, 有没有使用索引呢

严格来说属于索引截断,  不同的MySQL版本, 处理方式会不一样

5.5及以前, a会走索引, 联合索引找到主键值以后, 再回表, 到主键索引读取数据行, 比对c字段的值

5.6及以后, 有一个**索引下推**的功能, 在索引遍历的过程中, 因为c在索引中, 能在索引中判断的条件, 就不要等到回表后再去判断, 能有效减少昂贵的回表操作

### Where子句中的OR

在WHERE子句中, 如果在OR前面的条件列是索引列, 而在OR后面的列不是索引列, 就会造成索引失效

也就是如果id是索引列

```mysql
select * from t_user where id = 1 or age = 18;
```

这是因为OR的含义是两个只要满足其中一个就行了, 因此只有一个条件列是索引列是没有意义的

解决方法就是两个列都成为索引列, 这个时候就会根据索引分别扫描, 在最后将两个结果集进行合并

## 模糊查询 like %xxx一定会全表扫描吗

```mysql
select * from t_user where name like "%xxx";
```

一定会走全表扫描吗

需要查询出来的信息只有索引值 + 主键值, 这个时候就不会走全表扫描(type = ALL), 而是全扫描二级索引树(type = index)

, 也就是遍历了整颗二叉索引树. 这是因为需要查询的所有数据在二级索引的B+树中就能查到全部结果了, 这个时候就发生了覆盖索引

> 为什么在要查询的字段中有非索引字段的时候, 就会从全扫描二级索引树变成了全表扫描

因为如果走全扫描二级索引树, 就会变成, 在二叉索引树中找到了以后还要回表才能完成查询的工作, 同时因为是左模糊匹配, 导致并没有利用索引树的有序性快速定位数据







