# MySQL索引

## 为什么使用B+树作为索引的数据结构

而考虑索引的数据结构的核心考量之二就是

- 能在尽可能的磁盘I/O中完成查询操作
- 要能高效地查询某一个记录, 并且支持范围操作

这样的查找问题, 最直观的第一想法是使用二叉搜索树

但是二叉搜索树有链化的风险, 接下来的选择就是AVL树和红黑树, 这样是解决了平衡问题, 但是使用二叉平衡树, 每进入到下一层我们都需要进行一次磁盘的I/O, 所以我们需要尽可能矮胖的数据结构

于是我们看向了B树, B树是一个多叉树, 每一层能记录更多的节点, 同样的节点数量, B树更加地矮胖

但是B树的每个节点都包含了索引+数据, 但是实际上在查找到目标节点之前, 我们读取到的数据实际上是没有用的, 这样会有多余的磁盘I/O, 最终我们对B树做了一个升级, 就是B+树

我们将所有的数据都放在B+树的叶子节点上, 所有的非叶子节点只起到一个索引的作用, 通过这样的设计, 我们得到了一颗"矮胖"的搜索树, 并且搜索树的非叶子节点中只有索引数据, 同时B+树的叶子节点之间使用双向链表连接起来, 原生支持范围搜索.

最终通过B+树, 我们满足了上述的两个核心考量

## 聚簇索引和二级索引

- 聚簇索引的叶子节点存放的是实际数据, 所有的完整的用户记录都存放在聚簇索引的叶子节点
- 二级索引的叶子节点存放的是主键值

InnoDB在创建聚簇索引的时候选用的列按照以下顺序

- 如果指定了主键, 就使用主键作为聚簇索引的索引键
- 如果没有主键, 就选择第一个不包含NULL值唯一列作为聚簇索引的索引键
- 上面两个都没有的情况下, 就会自动生成一个隐式自增ID列作为聚簇索引的索引键

**如果某个查询语句使用了二级索引, 但是查询的数据不是主键值的时候, 在二级索引找到主键值以后, 需要去聚簇索引中获取数据行, 这个过程就叫回表. 不过当查询的数据是主键值的时候, 在二级索引中就能找到了, 就不用去聚簇索引中查找, 这个过程就叫索引覆盖**

## 什么时候需要分库分表了?

这个问题其实很明显最后是落在B+的层高在某个行数的时候会增加一层, 最后导致查询效率猛然降低

首先我们得分析一个B+树的非叶子节点能存储多少数据, 也就是多少索引

每个B+树的节点都是一个MySQL的数据页, 每个数据页固定`16KB`的大小, 除去其中的文件头, 页头, 校验信息等元信息, 最后可用的能存放数据的空间大概是`15KB`. 主键假设是Bigint(8byte), 页号是固定的(4Byte), 一个索引数据的大小就是12byte

最后一个B+树的节点能存放15 \* 1024 / 12 = 1280行索引

叶子节点和非叶子节点的结构是一样的, 能存放数据的空间都是15KB

我们假设每行数据的大小是Y, 则一个叶子节点能放15 \* 1024 /  Y行数据

设层高是z, 最后存放的行数是X = 1280^z \* 15 \* 1024 /  Y

在z = 3, Y = 1KB的时候, X = 2.45kw

在z = 3, Y = 5KB的时候, X = 500w

所以需要分库分表的行数需要根据每行的具体大小来得出, 一般在z > 3以后就要进行分库分表了, 没增加一层就会导致磁盘I/O的次数增加1次

**同时当单表数据库达到某个量级的上限以后, 导致内存无法存储其索引, 使得之后SQL查询会产生磁盘IO, 从而导致性能下降**

## 索引失效的原因

查询条件用上了索引列, 查询过程并不是一定会用上索引

### 使用like关键字左或者左右模糊匹配无法走索引

也就是使用这样的语句查询的时候

```sql
select * from t_user where name like %xx(or %xx%)
```

**因为索引B+树是按照索引值有序排序的, 只能根据前缀来比较**

如果使用左/左右模糊匹配, 查询结果的前缀会发生变化, 就不知道从哪个索引值开始比较了, 这个时候通过全表扫描的方式来查询

### 

