# MySQL基础

## 面试题

- MySQL 的 NULL 值会占用空间吗？
- MySQL 怎么知道 varchar(n) 实际占用数据的大小？
- varchar(n) 中 n 最大取值为多少？
- 行溢出后，MySQL 是怎么处理的？
- MySQL的NULL值怎么存放的 ?

## MySQL的数据是怎么存储的 ?

### 数据存储在哪?

- 在linux中, MySQL的数据会存储在`/var/lib/mysql/`这个目录下面, 每个数据库会在这个目录下面创立一个文件夹, 文件名就是库名
- 里面有db.opt, t_\<table_name>.frm, t_\<table_name>.ibd三类文件
    - db.opt, 用于存车处当前**数据库**的**默认字符集**和**字符校验规则**
    - table.frm, 这张表的**表结构**会保存在这个文件. 在MySQL中每建立一张表大都会生成一个.frm文件, 用于记录这个表的元信息, 主要是定义表的结构
    - table.ibd文件 : 记录了表的**表数据**. 表数据既可以存在共享表空间文件 (ibdata1) 中, 也可以存储在独占表空间文件中(ibd)文件中. 这个行为由参数**innodb_file_per_table**控制, 若设置参数innobd_file_per_table的值为1, 就会将存储的**数据**, **索引**等信息单独存储在独占表空间, 从5.6版本以后, 这个参数就已经默认设置为1了
    
### 表空间文件的结构是怎么样的

**表空间由段(segment), 区 (extent), 页(page), 行(row)组成**, 这些部分之间的关系可以从下图粗略看出来

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/表空间结构.drawio.png)k

#### 1. 行 (row)

数据库中的数据都是以行进行存放的, 每行记录根据不同的行格式, 有不同存储结构
后面会详细说明行格式

#### 2. 页 (page)

- 行是记录一次数据的最小单位, 但是数据库与磁盘的交互, 从磁盘中读取数据, 行并不是最小的单位, 不然每IO一次磁盘只能处理一行数据, 效率过于低下
- **InnoDB的数据是按[页]为单位进行读写的**, 也就是读取一条记录的时候, 并不是只将这行的数据从磁盘IO到内存, 而是将一页的数据IO到内存中 
- **默认一页的数据是16KB**, 也就是最多能保证16KB的连续空间(空间局部性, 顺序IO的性能高于随机IO)
- 页是InnoDB存储引擎磁盘管理的最小单元, 也就是每次读写, 都是最少将一整页的数据读取出来, 再将这一整页的数据刷新回磁盘
- 页有很多种种类, 数据页, undo日志页, 溢出页. 数据表中的行记录使用数据页来管理的

#### 3. 区 (extent)

- InnoDB 使用B+tree树来组织数据
    - 使用索引来作为非叶子节点
        - 有主键则使用主键
        - 没有主键则使用第一个非空唯一索引作为主键
        - 再没有就使用隐藏主键
    - 每个叶子节点就是一页数据
    - B+树每一层之间都是使用双向链表将数据连接起来
- 如果使用页作为单位分配空间, 就无法保证链表中相邻的页的物理位置并不是相邻的, 而对于磁盘随机IO慢于顺序IO
    - **为什么保证逻辑上相邻的页之间物理位置也相邻很重要?**
        - 空间局部性 : 计算机程序在访问一个特定的内存位置以后, 很可能会在不久之访问相邻的内存位置, 这是计算机系统设计的一个基本假设
        - 空间局部性能提高磁盘的IO性能 : 顺序IO替代随机IO
        - **显著提高范围查询和顺序扫描的性能**

- 那么怎么解决呢? 我们该怎么保证相邻页数据尽量满足在磁盘中相邻呢
    - **在表中数据量大的时候, 为某个索引分配空间的时候, 就不再按照页为单位分配了, 而是按照区为单位分配, 每个区的大小是1MB, 对于16KB的页来说, 连续的64页会被划分到一个区, 这样就使得链表中相邻的页的物理位置也能相邻, 就能再更大的范围顺序IO了**
    
#### 4. 段(segment)

> 表空间由多个段组成, 一个段由多个页组成. 段一般分成数据段, 索引段, 回滚段
> 段 **一组拥有相似用途的页的集合**, 是一种逻辑上的结构

- 索引段 : 存放B+树的非叶子节点的区的集合
- 数据段 : 存放B+树对的叶子节点的区的集合
- 回滚段 : 存放的是回滚数据的区的集合

- 在物理存储上
    - 数据段和索引段通常位于同一表空间文件中
        - 系统表空间
        - 独立表空间
    - 回滚段可以位于
        - 系统表空间
        - 专用的UNDO表空间
        - 临时表空间

## 行格式 (row format)

> 行格式就是MySQL存储一行数据的逻辑结构, 一行数据中包含了什么内容, 一条记录的存储结构

- 有四种行格式 : Compact, Dynamic, Compressed, Redundant
    - Reddundant很古老, 基本不使用了
    - Compact和Dynamic以及Compressed相似, Dynamic和Compressed更为紧凑

> 5.1 以后默认使用Compact, 5.7以后默认使用Dynamic

### COMPACT行格式是怎么样的

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

- 可以将一条记录分为 **记录的额外信息** 和 **记录的真实数据** 两部分

#### 变长字段长度列表

- 在MySQL有像varchar(n)这样的变长的字段, 它们存储的数据的长度是不确定的
- 变长字段长度列表就是记录所有(非NULL)的变长字段的长度信息的, 这样我们在后续读取数据的时候才知道读多长

我们用例子说明变长字段长度列表是怎么工作的, 字符集是ascii(所以每个字符占一个字节)
```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `name` VARCHAR(20) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

这是表中的数据
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png)

- 看第一条记录
    - name列 : 值为a, 长度为0x01
    - phone列 : 值为123, 长度为0x03
- 变长字段的真实数据的占用的字节数会按照列的顺序 **逆序存放** , 所以变成字段长度序列里的内容是 `[03, 01]`
- 同理, 其他两行的变长字段长度序列为
    - `[04, 02]`
    - `[03]`

> 为什么 **变长字段长度列表** 需要使用**逆序存储** ?

- 记录头信息中指向下一条记录的指针, 指向的是下一条记录的记录头信息, 和真实数据


## varchar(n)中n的最大取值是多少

## 行溢出后, MySQL是怎么处理的