# TCP 三次握手与四次挥手常见面试题

## TCP基本认识

### TCP头格式有哪些内容

![TCP头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

- *序列号* : 在建立连接时计算机生成的**随机数**作为初始值, 通过SYN包传给接收端主机, **每发送一次数据就会累加一次, 用于解决网络包乱序的问题**

- *确认应答号* : 下一次期望收到的数据的序列号, 发送端收到这个确认应答以后, 可以认为在这个序列号之前的数据都已经被正常接受. **用来解决丢包问题**
- 控制位 :
  - **ACK** : 该位置为1的时候, **确认应答字段变为有效**, TCP规定除了最开始建立连接时的SYN包之外, 该位必须为1
  - **RST** : 该位置为1的时候, 表示**TCP连接出现异常**, 必须强行断开连接
  - **SYN** : 该位置为1的时候, 表示**希望建立连接**, 需要计算机生成随机值初始化序列号
  - **FIN** : 该位置为1的时候, 表示今后不会再有数据发送过来了, 希望**断开连接**. 当通信结束希望断开连接的时候, 通信双方的主机之间就可以相互交换**FIN位为1 的TCP段**

### 为什么需要TCP协议? TCP在哪一层

IP层提供的服务是不可靠的, 不能保证**网络包的交付**, 不保证网络包的**按序交付**, 也不保证网络包中的数据的**完整性**

TCP在网络层的上一层传输层, 保证了网络包传输的可靠性, 保证接收端接收的网络包是**无损坏, 无间隔, 非冗余和按序的**

### TCP是什么

TCP是**面向连接的, 可靠的, 基于字节流的**传输层协议

- **面向连接** : 必须是一对一的连接, 和UDP可以一个主机同时向多个主机发送消息, 一对多在一个TCP连接中是无法做到的
- **可靠的** : 能保证一个报文一定能够到达接收端
- **字节流** : 用户发送一个消息给接受端, 操作系统可能会将这个消息分组为多个TCP报文, 如果接收端不知道消息的边界, 是无法有效读出来用户的原消息的. 并且TCP报文是**有序的**, 当前一个报文没有收到的时候, 即使后面的报文已经收到了, 也不会交给应用层去处理

### TCP连接是什么

**用于保证可靠性和流量控制维护的某些状态信息, 这些信息的组合, 包括Socket, 序列号和窗口大小称为连接**

所以建立一个TCP连接, 客户端和服务端需要在三个信息上达成共识

- **Scoket**: 由IP:port组成
- **序列号**: 用来解决乱序问题
- **窗口大小** : 用来做流量控制

> 如何唯一确定一个TCP连接?

源地址 + 源端口, 目标地址 + 目标端口

源地址和目标地址存在IP头部中, 作用是通过IP协议发送报文给对方主机, IP协议发送报文的粒度是主机

源端口和目标端口存在TCP头部中, 告诉TCP协议应该把报文发送给哪个进程, TCP协议发送报文的粒度是进程

### TCP和UDP有什么区别呢

UDP是通过IP协议实现了**无连接**的通信服务

其头部很简单, 只有8字节

- 目标和源端口 : `4字节`
- 包长度 : `2字节`
- 校验和 : 防止收到在网络传输中受损的UDP包, `2字节`

两者的区别

*1.连接* : 

- TCP是面向连接传输的协议, 传输之前需要先建立连接
- UDP是无连接的协议

*2.传输对象*

- TCP只能实现一对一的两点之间的通信
- UDP能实现一对多, 多对一, 多对多的通信

*3.可靠性*

- TCP是可靠交付数据的, 数据可以无差错, 不丢失, 不重复, 按序到达
- UDP不保证可靠交付数据, 但是我们能通过UDP实现一个可靠的传输协议, 比如QUIC

*4. 拥塞控制, 流量控制*

- TCP有, 能保证数据传输的安全性
- UDP没有, 即使网路很拥堵了, 也不会影响UDP发送的速率

*5. 首部开销*

- TCP首部长度在没有使用\[可选]的字段的时候是`20字节`, 使用了还会更长
- UDP首部长度是固定的`8字节`

*6.传输方式*

- TCP是流式传输, 没有边界
- UDP是一个包一个包发送的, 有边界, 但是会有乱序和丢包

*7. 分片不同*

- TCP根据MSS大小, 如果大于了就会在传输层中分片, 接收方同样在传输层组装TCP数据包
- UDP根据MTU大小分片, 如果大了, 就会在IP层分片, 接收方同样是在IP层组装数据

> TCP头部中没有包长度的字段, 而UDP中有呢

其实TCP也是能计算出来负载数据的长度的

$TCP数据的长度 = IP总长度 - IP首部的长度 - TCP首部长度$

UDP中之所以会将数据作为包来处理, 其实是整个协议栈和API刻意保留了消息边界的设计, 更加强调UDP的独立性

而TCP中会将数据作为流来处理, 这是一种设计决策上和设计理念上的差异

### TCP和UDP能使用一个端口吗

**可以**

在数据链路层, MAC地址用来寻找局域网中的主机. 在网路层中, 通过IP地址来寻找网络中互连的主机或者路由器. 在传输层中, 通过端口地址寻址, 为了找到同一计算机中同时通信的不同应用进程

传输层中的端口号是为了区分不同应用进程的数据包

在内核中, 传输层协议TCP和UDP是完全独立的软件模块

当主机收到数据包以后, 根据IP包头协议号字段知道该数据包是TCP还是UDP, 从而交给不同的模块处理. 送给TCP/UDP模块的报文, 根据端口号知道送给哪个应用进程处理

## TCP连接建立

### TCP连接三次建立的过程

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 服务端先进入到`LISTEN`状态监听某个端口
- 客户端从`CLOSE`进入到`SYN_SENT`状态发送第一个报文: `SYN`报文
  - 客户端随机初始化序号(`client_isn`)给序列号
  - SYN标志为1, 表明客户端想建立一个连接
- 服务端接收到了`SYN`报文, 从`LISTEN`状态进入到`SYN_RCVD`状态, 发送第二个报文 : `ACK + SYN`报文
  - 服务端随机初始化序号(`server_isn`)给序列号
  - 把收到的客户端的`ISN + 1`填入到确认应答号中
  - `SYN`标志为1, 表明服务端想建立一个连接
  - `ACK`标志为1, 确认应答字段有效
- 客户端收到了`ACK + SYN`报文, 从`SYN_SENT`进入到`ESTABLISHED`状态, 发送第三个报文 : `ACK`报文
  - 将收到的服务端的`ISN + 1`填入到确认应答号中
  - 将`ACK`置1
- 服务端收到了`ACK`报文以后, 进入到`ESTABLISHED`状态

**第三次握手的时候是可以携带数据的, 前两次握手的时候不能携带数据**

这之后就能相互发送数据了

### 如何在linux中查看TCP状态

通过`netstat -napt`命令

### 为什么是三次握手, 不是四次或者两次?

什么是TCP连接

- 用于保证可靠性和流量控制而维护的某些状态信息, 这些信息的组合, 包括**Socket, 序列号和窗口大小**称为连接

所以问题就变成了为什么三次握手才可以初始化Socket, 序列号和窗口大小并建立TCP连接

- 三次握手才能阻止重复历史连接的初始化(主要原因)
- 三次握手才能同步双方的序列号
- 三次握手能避免资源浪费

#### 原因一: 避免历史连接

TCP连接使用三次握手的**首要原因就是为了防止\[历史连接]初始化连接造成混乱**

考虑这样的场景, 客户端线发送了SYN (seq = 90)的报文, 然后客户端宕机了, 一段时间重启以后, 重新发送了SYN (seq = 120)的报文希望重新建立连接, 但是SYN (seq = 90)的报文被网络阻塞了, 两个报文最后seq=90的先到达, 马上seq=120的也到达了服务端

三次握手是怎么阻止历史连接的

- 旧`SYN(seq=90)`先到达, 服务端接收到以后, 向客户端发送`ACK + SYN(Ack Num = 90 + 1, Seq Num = 300)`报文
- 客户端接收到以后, 发现`Ack Num`和自己期望的`Ack Num = 120 + 1`不一样, 发起`RTS`报文终止了连接
- 新的`SYN(seq=120)`到达了服务端, 服务端接收到以后, 向客户端发起了`ACK + SYN(Ack Num = 120 + 1, Seq Num = 400)`报文
- 客户端接收到以后, 发现对上了`Ack Num`, 返回`ACK(Ack Num = 400 + 1, Seq Num = 121)`报文
- 服务端接收到`ACK`报文以后, 进入到了连接`ESTABLISHED`状态, `TCP`连接建立

**如果使用两次握手, 就没有中间状态阻止历史连接, 服务端可能会建立一个历史连接, 造成资源的浪费**

因为是两次连接, 服务端在接收完`ACK + SYN`报文以后, 就会进入到`ESTABLISHED`状态, 从服务端的角度来看, 连接就已经建立好了, 这个时候服务端就可以向客户端发送消息了, 但是实际上这是一个\[历史连接], 发送的数据完全是无效浪费的,  在客户端接收到`ACK + SYN`报文以后, 向服务端发送`RST`报文以后, 连接才会被废除, 服务端**白白建立了一个不会被使用的历史连接**, **可能会导致数据的丢失, 一定造成了资源的浪费**

> TIP
>
> 第三次握手最关键的地方在于客户端发送的报文是ACK报文, 如果客户端发送完三次握手报文以后再发送了一些数据, 但是前面的三次握手报文丢失了, 这个时候连接还没有建立数据会丢失吗?
>
> 不会丢失, 因为后面的携带了数据的报文也是ACK报文, 服务端收到以后还是会建立连接, 这也是第三次握手的时候可以接收数据的一个体现

#### 原因二: 同步双方的序列号

TCP协议的通信双方, 都必须维护一个序列号

- 接收方可以通过序列号去除重复的数据
- 接收方可以通过序列号按序接收数据包
- 可以标识已经发送出去的数据包哪些被对方收到了(根据ACK报文中的序列号知道)

所以TCP不能没有序列号, 就像西方不能没有耶路撒冷

而TCP协议通信双方初始化序列号的过程可以分成下面四步

- 发送方 -> 接收方 Seq Num = client_isn
- 接收方 -> 发送方 Ack Num = client_isn + 1来确认已经成功接收
- 接收方 -> 发送方 Seq Num = server_isn 
- 发送方 -> 接收方 Ack Num = server_isn + 1

接受方和发送方都需要发送一个SYN报文来传递序列号, 另一边都需要发送一个ACK报文来表示自己已经成功收到了, 所以最少有四步, 但是接收方发送Ack Num和Seq Num能合成同一步, 所以最少需要三次握手

#### 原因三: 避免资源的浪费

如果使用两次握手, 服务端就得在发送完SYN + ACK报文以后就进入到ESTABLISHED状态, 为历史连接分配了资源, 浪费资源

#### 总结

为什么是不使用两次握手和四次握手

- 两次握手 : 没办法可靠得同步双方的序列号, 无法防止历史连接的建立, 会造成双方资源的浪费
- 四次握手 : 三次握手就已经能够理论上建立最少可靠连接, 所以不需要更多的连接次数

### 为什么每次建立TCP连接时, 初始化的序列号都要求不一样

- **如果每次建立连接的时候, 客户端和服务端初始化的序列号都是一样的, 很容易出现历史报文被下一个相同四元组的连接接收的问题**, 而如果每次建立TCP连接的时候初始序列号都不一样, 就能够区分出来历史报文和现在要接收的报文, 从而很大程度上避免了历史报文被接收
- 为了安全性, 防止黑客伪造相同序列号的TCP报文被接收

### 初始序列号ISN是如何随机产生的

ISN = M + F(loaclhost, localport, remotehost, remoteport)

- M是一个计时器, 每4微妙 + 1
- F(loaclhost, localport, remotehost, remoteport)是一个由四元组通过hash算法计算出来的随机数值. 可以使用MD5

### 既然IP层会分片, 为什么TCP层还是需要MSS呢

如果只使用IP层的MTU来分片, 就会出现下面的情况

一个IP数据报长度超过了MTU, 被切分成了多个IP分片, 然后在IP层传输, 其中的一个数据报丢失了, TCP层接收到以后无法组装成一个完整的TCP报文段, 也就无法发送给接收端, 这个时候就会在超时以后触发超时重传机制, **因为整个IP报文才具有确认机制, 所以整个IP报文会被重传**

**TCP通过MSS进行数据分段, 每个分段单独封装在TCP报文段中, 形成独立的IP数据报进行传输, 避免了IP层分片. 这使得TCP能单独确认和重传每个分段, 而不会因为单个分段丢失而重传所有数据**

###  第一次握手丢失了, 会发生什么

客户端在发送了SYN报文以后, 进入到SYN_SENT状态

如果客户端无法在规定的时间内收到服务端的SYN-ACK报文(也就是第二次握手), 就会触发超时重传机制, 重传SYN报文(Seq相同, 表示仍处于同一次TCP连接建立尝试中)

不同版本的操作系统的中的超时时间是不一样的

当客户端在1s后没有收到报文, 就会重传 ,重传的次数由tcp_syn_retries来控制

```conf
# cat /proc/sys/net/ipv4/tcp_syn_retries
5
```

第一次超时重传是在1s后, 第二次就是2s, 第三次就是4s, 第四次就是8s, 第五次就是16s, **每次超时时间是上一次的两倍**

第五次超时重传以后, 会继续等待32s, 如果还没有收到SYN-ACK, 就会断开TCP连接



### 第二次握手丢失了, 会发生什么

如果第二次握手丢失了, 就会导致

- 客户端认为自己的报第一次握手SYN报文没有发送到服务端, 进行超时重传
- 服务端一直没有收到第三次握手, 也触发超时重传

服务端超时重传的策略和第一次握手的, 每次重传的超时时间翻倍策略一样, 配置重传次数的参数是

```conf
# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

### 第三次握手丢失了, 会发生什么

也是一样的重传, 服务端认为自己的报文丢失了, 超时重传到接收到ACK或者达到最大的重传次数

### 什么是SYN攻击, 怎么避免SYN攻击

Linux内核会维护一个半连接队列和全连接队列

正常流程

- 服务端接收到客户端的SYN报文的时候, 就会创建一个半连接对象放入到半连接队列(SYN队列)中
- 接着发送SYN+ACK给客户端
- 等到接收到客户端的ACK以后, 从半连接队列中取出来一个半连接对象, 创建一个新的连接对象放入到Accept队列中
- 应用通过调用`accept()`socket接口, 从Accept队列中取出连接对象

攻击者发起SYN攻击, 就是不断使用虚假的IP:port, 然后占满SYN队列, 这样**当TCP半连接队列满了以后, 后续再收到的SYN报文就会丢失, 导致客户端无法与服务端建立连接**

解决方法

> 方式一 : 增大TCP半连接队列

通过增大下面的三个参数

- net.ipv4.tcp_max_syn_backlog
- listen()函数中的backlog
- net.core.somaxconn

> 方式二: 开启 net.ipv4.tcp_syncookies

开启这个功能就可以在不使用SYN半连接队列的情况下成功建立连接

- 当SYN队列满了以后, 后续服务端收到SYN包, 不会丢弃, 而是根据算法计算出来一个`cookie`值
- 将cookie值放入到第二次握手报文的序列号里面, 然后服务端会第二次握手给客户端
- 服务端接收到客户端的应答报文时, 会检查这个ACK包的合法性, 如果合法, 将该连接对象放入到Accept队列
- 最后应用程序通过调用`accept()`接口, 从Accept队列中取出连接

net.ipv4.tcp_syncookies的参数主要有三个值

- 0值, 表示关闭该功能
- 1值, 表示仅当SYN半连接队列放不下的时候, 再启用它
- 2值, 无条件开启功能

> 方式三 : 减少SYN+ACK重传次数

减少重传的次数, 就能减少SYN报文在SYN队列中停留的时间

