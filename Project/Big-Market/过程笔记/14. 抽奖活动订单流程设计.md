


# 这节做了什么

> 这节主要是创建了活动抽奖的主要框架, 这个框架和strategy那边的框架其实类似

- 创建各个实体类
- 创建值对象
    - 活动状态值对象
    - 订单状态值对象
- 创建聚合对象
- 活动仓储层
- 服务层 : 我们主要在这个位置实现业务逻辑
    - 单一功能接口IRaffleOrder : 创建订单接口
    - AbstractRaffleActivity : 用于定义活动抽奖的过程
    - RaffleActivityService extends AbstractRaffleActivityService : 实现抽奖的过程中的各个组件
# 学到了什么

## DDD架构下的接口等的编排

- 接口定义单一职责的功能 
- 抽象类定义某些复杂的过程
- 继承抽象类的服务类实现抽象类中的各个组件
## DDD中的各种类别的类

### VO对象

> Value Object 值对象

- 与VO对象相对的就是实体对象, 这两者的核心区别是
    - VO对象没有唯一ID, 里面包含了很多通用的信息, 一般来说就是一个枚举类, **相等判断基于所有的值**
    - 不同的Entity即使值相同, 但是唯一ID不同, 也是不一样的实体, 但是但对于VO对象来说就算不是, **相等判断基于ID**
- 一般来说, VO对象就是一个**enum**类

### Aggregate聚合对象

- 用于将一组相关的对象作为一个整体

- 优点
    - 聚合是一个事务边界, 要么整体成功, 要么整体失败
        - 保证了成员数据一致性, 能够同意管理一组对象 (TCP请求结构体就是一个聚合对象, 里面有各个部分, 我们使用它只需要将其作为一个整体考虑, 并且这一个整体内是保持了数据一致性)

#### 数据一致性

> 数据一致性指确保数据在各个系统, 组件或操作之间保持准确, 完整和可靠的状态

## SKU

> stock keeping unit : 库存量单位, 代表的是活动商品的唯一标识

- SKU的作用 
    - SKU中有整个活动配置的聚合
        - sku
        - 活动ID
        - 次数编号
        - 库存剩余
        - 库存总量
        - 创建时间
        - 更新时间
    - 通过这个SKU, 我们能查到这个活动的所有信息
- 同时一个SKU就是一个商品, 这些商品能共享一个活动, 这个表主要是用来解耦商品和活动
- 因为我们会出现一个多个商品共享一个活动的情况, 它们共享一套配置, 比如说, 用户通过签到和充值都能获得同一个活动的奖品, 这个时候我们就能灵活地配置

## 幂等性

> 在系统设计中的含义是 : 对同一操作执行一次或者多次, 其结果应该是一样的. 通俗地说, 多次调用对系统产生的影响是一样的, 即对资源的作用是一样的

- 拿数据库举例, mysql就实现了幂等性
    - SELECT 语句不涉及对数据的变动, 天生就具有幂等性
    - UPDATE, DELETE等语句多次执行的结果是一样的, 具备幂等性, (这里指的是绝对值删除, 也就是 id = x这种)
    - 与之相对的, 使用相对值进行UPDATE, DELETE, 就不具备幂等性, 我们多次运行的结果是不一致的

- 在这里我们SKU的设计中, outBusinessNo字段的是业务的单号, 通过这个业务单号, 我们来实现幂等性, 即使我同一个请求发送多遍, 系统也只会处理一次
