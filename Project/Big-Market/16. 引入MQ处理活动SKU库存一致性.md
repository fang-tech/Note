# 实现了什么

## 实现的内容

- 和前面实现策略奖品扣减一样实现了加锁的在缓存中的扣减库存操作, 同时延迟队列延迟将数据库更新操作加入队列以减轻数据库压力, 数据库定时异步更新
    - 额外加上了MQ, 如果缓存中剩余库存扣减至0, 直接清空队列(延时队列和阻塞队列), 并发送请求将数据库中的剩余库存清空至0 
    - 对于并发量很高的情况, 比如秒杀这种情景, 通过消息队列能有效减少对数据库的操作数量
    
- 填充实现了责任链中的具体的过滤逻辑和对于责任链的组装

# 学到了什么

## 库存扣减流程

> 算是重温了一遍在第一阶段中的库存扣减操作, 同时加上了MQ额外处理库存变成0的情况

### 预处理
- 预热, 将sku商品的数量加载到redis缓存中

### 库存扣减

- 责任链过滤
    - 用户发送请求扣减库存 -> skuRecahrgeCard实体对象(商品充值实体) -> 责任链过滤请求(确保请求是正确, 需要被响应的请求) -> 活动状态是open -> 在活动时间内 -> 活动sku库存数量 > 0 -> 扣减库存校验责任链 (尝试进行扣减操作, 确保扣减成功, 这种时候才会返回订单号)

- 库存扣减
    - 尝试通过仓储层扣减redis中的库存
        - 扣减完毕得到扣减后的库存数量 > 0 : 说明是合理的扣减
            - 检验这个库存是不是扣减过
                - 没有扣减过 -> 将这个剩余库存加锁 -> 将扣减更新数据库的信息添加到延迟队列中 ->  返回扣减成功 
                - 扣减过 -> 说明这个库存扣减过, 出现错误, 返回扣减失败
        -  == 0 : 说明这个时候刚好将所有的库存扣减完了, 走特殊处理 -> 将Message发布到RabbitTemplate中 -> ActivitySkuStockZeroCustomer监听这个特殊处理的信息 -> 听到以后, 将库存清零, 将队列清空

### 扣减库存中的数据一致性保证

- redis的decr操作本身就带有原子性, 能保证用户扣减缓存中的库存是原子的
- 通过给扣减过的库存加锁, 保证了库存不会在运营错误配置的情况下超卖
- 异步的数据库同步保证了最终一致性

### 削峰操作

> 该操作主要是为了减少数据库的压力

- 异步的定时数据库IO, 而非实时的更新任务
- MQ消息队列处理为零的特殊情况, 直接一步到位, 只需要设置一次值就完成了延迟队列里的更新任务, 只需要执行一次更新操作