# 需求分析

> 在上一节实现了规则树模型的结构的设计, 这节我们在数据库中加上相关的关于规则树的配置的信息, rule_tree, rule_tree_node, rule_tree_node_line三个库表, 
> 
1. 通过从其中查到的信息构建规则树
2. 重构抽奖过程, 去掉filter的部分

# 重构的流程 : 在drawio的图中有详细的描述

# 对于设计模式的总结

## 建造者模式 Builder

### 说明

相较于构造模式是更灵活的一种创建一个新对象的方式, 我们能任意选择该类的字段进行创建一个新的对象, 而不再是需要传入全部的参数, 或者只能按照我们有的构造方法创建新的对象

### 疑惑

但是其实这样的过程等同于使用setter在无参创建以后赋值, 这个设计模式主要是为了简化这个创建然后set的过程吗

## 责任链

### 说明

- 执行的功能和switch case语句相似, 相当于我们构建一个case组, 并在其中选择性的break(也就是接管), 不break就会进入到下一个case(也就是放行)
- 我们会顺次执行链中的事件节点, 并在当前节点判断我们是需要在这个节点就返回结果(TAKE_OVER), 还是放行进入到下一个节点继续进行下一个事件(ALLOW)

### 对比if else的优势

相较于if else肯定是在编码上更加复杂了的, 但是也带来了更多的灵活性以及非侵入式的添加这个"if else"中情况的可能遵守了OCP开闭原则
- 灵活性 : 我们能通过配置数据库以及添加责任链节点类的实现类来为责任链中添加链结
- OCP与非侵入式 : 我们现在添加一个新的过滤规则, 不再需要修改原先的其他的链节点事件的代码, 只需要添加新的节点的代码, 数据库中的数据

## 决策树

### 说明

- 决策树其实比起说是一个单独的设计模式, 更像是责任链设计模式的上位替代, 在决策树中我们每条从根节点到叶子节点的过滤过程就是一条过滤的责任链
- 对于责任链来说, 理论上来说, 能用决策树实现的过滤流程, 我们同样能用多组责任链, 并将其中的链节连接起来的实现
    - 以及将这些链进行合并我们就能得到一颗树, 只不过这颗树的边只有EQUAL规则, 并且只能构造成一颗二叉树, 因为我们只有放行和接管两种选项

### 决策树和责任链

- 决策树与责任链相比, 有更灵活的方式选择这个事件现在到下一个事件之间的规则, 也就是决策树是能构建成一颗多叉树的, 因为对于每条边之间我们都能设置什么时候边的入节点才能到达这条边的出节点

