# 栈帧内存结构

## 局部变量表

**存储方法的参数和局部变量, 由基本数据类型和对象引用(每个方法都有一个特殊的指针this, 也就是每个方法的最小的局部变量的数量是1个)构成**

在**编译的时候, 局部变量表的最大容量就已经确定**了, 通过方法的Code属性的`Maximum Local variables. `

同时局部变量的**容量最小单位是slot(槽位),** 一个槽位可以容纳`32bit(4byte)`的数据类型, 也就是一个`double(64bit)`类型的变量, 占用两个slot

```java
public void slot(int age){
    double d = 10.0;
}
```

这个方法的局部变量表大小是4

同时**局部变量的数量是会在运行的时候发生变化的(因为变量会在运行的时候随着作用域被创建和销毁)**

```java
public void test() {
    { // 注释中的是代码运行到这一行的时候, 局部变量表的大小
        // 1
        String name = "hello";
        // 2
    }
    // 1
    {
        // 1
        int age = 10;
        // 2
    }
}
```

## 操作数栈

**栈结构, 用于存储数据和和中间计算结果**

和局部变量表一样, **操作数栈的最大大小在编译的时候也被确定了**, 在方法的Code属性中 `Maximum stack size`, **因为操作数的占用的槽位是确定的, 字节码指令的栈效应是可预测的**, 也就能计算出来这个方法需要用到的最大的操作数栈深度

当一个方法开始执行的时候, 操作数栈是空的, 在运行的时候, 随着指令的运行, 会不断向操作数栈中压入数据和取出数据执行操作

## 动态链接

**关联到方法所属了类的常量池, 支持多态方法的核心机制**

**每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用的目的时为了支持方法调用过程中的动态链接**

- 方法区是JVM运行时内存区域, 属于逻辑定义
- 运行时常量池时方法区的一部分, 用于存放编译期间生成的各种字面量个符号引用-在类加载后进入运行时常量池

从字节码的角度来看, 多态地调用方法是完全一样的, 但是最后调用的方法不一样

`man.sayHello()`（第 10 行）和 `woman.sayHello()`（第 12 行）对应的字节码都是`invokevirtual #6 <com/.../DynamicLinking$Human.sayHello`

关键在于`invokevirtual`指令入手, 这个指令在运行的时候解析过程可以分成以下几步

1. 找到操作数栈顶的元素所指向的对象的实际类型, 记作C
2. 找到以后, 进行访问权限校验, 通过则返回这个方法的直接引用, 否则`java.lang.IllegalAccessError`
3. 否则按照继承关系向上找C的父类
4. 如果始终没有找到合适的方法, 抛出`java.lang.AbstractMethodError`

## 方法返回地址

**记录方法结束后控制流应该返回的位置**

方法执行以后有两种方式退出

- 正常退出, 有可能将返回值传递给上层方法的调用者, 方法是否有返回值和返回值的类型根据返回的字节码指令来定 `ireturn `用于返回 `int `类型，`return `用于 `void `方法；还有其他的一些，`lreturn `用于 `long `型，`freturn `用于 `float`，`dreturn `用于 `double`，`areturn `用于引用类型。
- 异常退出, 如果没有得到妥善的处理, 这种时候不会给上层的调用者提供返回值

方法正常退出的时候, PC计数器的值会作为返回地址, 栈帧中很可能会保存这个计数器的值, 异常退出时则不会

方法退出以后就是将当前活动栈帧出栈, 然后

- 恢复上层方法的局部变量表和操作数栈
- 把返回值压入调用者栈帧的操作数栈中
- 调整PC计数器的值, 找到下一条要执行的指令

## 附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中, 例如与调试相关的信息, 这部分信息完全取决于具体的虚拟机的实现. 实际开发中, 一般会把动态链接, 方法返回地址与附加信息归为一类, 称为栈帧信息