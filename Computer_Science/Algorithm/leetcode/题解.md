## 单调队列

### 核心

- 单调队列能在数组每个元素都只进出双端队列一次的前提下,  保持队头是原数组中的某个子序列中的最大或最小值, 并且能持续获取
- 特征
  - 队头的元素始终是整个对列中的最大(小)的
  - 可以从队头`pop_front`或者`front()`, 但是队尾既能`pop_back()`, 也能`back()和push_back()`
- 构建代码的核心
  - 窗口是怎么移动的, 如何标定窗口的起始位置, 一般来说存入队列的元素并不直接是数值, 而是下标, 这样有利于删头的时候判断当前元素是不是在窗口中
  - 什么时候删头 (删头一般是元素在窗口外面的时候的处理)
  - 什么时候输出, 即从队列中取出元素, 打印或存入最终的数组中
  - 什么时候去尾 (一般是添加新的元素的时候, 很难有变化)

### 滑动窗口

#### P239.[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

- 一句话题解 : 通过单调队列能实现, 每个元素只进出队列一次就能获取到窗口的最大(小)值

- code 
  ```cpp
  /*
   * @lc app=leetcode.cn id=239 lang=cpp
   *
   * [239] 滑动窗口最大值
   */
  #include <vector>
  #include <deque>
  #include <iostream>
  using namespace std;
  
  // @lc code=start
  class Solution {
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          vector<int> ret;
          deque<int> dq;
          for (int i = 0; i < nums.size(); i++) {
              // 删尾
              while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();
              dq.push_back(i); 
              if (i >= k-1) {
                  // 删除头部不属于目前窗口的内容
                  while (!dq.empty() && dq.front() <= i-k) dq.pop_front();
                  ret.push_back(nums[dq.front()]);
              }
          }
          return ret;
      }
  };
  // @lc code=end
  ```

#### P1438.[绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)

- 一句话题解 : 连续子数组其实就是一个个的窗口, 窗口end就是i, 窗口begin向后滑动的条件是窗口中出现了超过限制的数, 一直滑动到正常为止, 这样的解法保证了每个元素只进出窗口一次, 需要特别注意的是这种解法的**边界条件** : 计算length的时机, 如果只是在出现了超过限制的数的时候计算, 就会出现如果最长子数组是窗口滑动到最后出现的, 这种情况因为没有超过限制是不会计算的, 并且这种时候length = end - begin + 1, 其他时候应该是length = end - begin 

- code
  ``` cpp
      int longestSubarray(vector<int>& nums, int limit) {
          deque<int> max_dq, min_dq;
          int length = 0;
          int begin = 0;
          for (int i = 0; i < nums.size(); i++) {
              // max的去尾
              while (!max_dq.empty() && nums[i] < nums[max_dq.back()]) max_dq.pop_back();
              max_dq.push_back(i);
              // min的去尾
              while (!min_dq.empty() && nums[i] > nums[min_dq.back()]) min_dq.pop_back();
              min_dq.push_back(i);
              
              // cout << "begin : " << begin<< ", end : " << i;
              if(abs(nums[max_dq.front()]-nums[min_dq.front()]) > limit) {
                  length = max(length, (i-begin));
                  // cout << "  计算了length";
                  while ((begin <= i) && abs(nums[max_dq.front()]-nums[min_dq.front()]) > limit) {
                      begin++;
                      while (max_dq.front() < begin && !max_dq.empty()) max_dq.pop_front();
                      while (min_dq.front() < begin && !min_dq.empty()) min_dq.pop_front();
                  }
              }
              if (nums.size() - i == 1) {
                  length = max(length, (i-begin+1));
              }
              // cout << ", length : " << length << endl;
          }
          return length;
      }
  };
  // @lc code=end
  int main() {
      Solution s;
      cout << "case 1 : " << endl;
      vector<int> input = {10,1,2,4,7,2};
      int limit = 5;
      cout << s.longestSubarray(input, limit) <<endl;
      cout << "case 2 : " << endl;
      input = {8,2,4,7};
      limit = 4;
      cout << s.longestSubarray(input, limit);
      return 0;
  }
  ```

### 最大子序和❓

- 题目 : P53.[最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

- 用单调队列优化DP, 但是还没学到DP还有前缀和, 所以搁置

##  单调栈

### 核心

- 特性 : 
  - 常用于处理比较问题, 或者是涉及字符匹配问题
  - 和单调队列一样, 能通过只让每个元素只进出栈一次的情况下, 完成比较
- 使用时关注的问题 :
  - 是涉及比较还是字符匹配
  - 入栈的时机
  - 出栈的时机

### 题目

#### P2454.[下一个更大元素 IV](https://leetcode.cn/problems/next-greater-element-iv/description/)

- 一句话题解 : 这题是常规的"下一个更大元素的拓展", 所以需要先说明原题的解法, 
  - 题目 : 找到每个元素的下一个更大的元素, 返回这个存有更大的元素的数组, 原题的思路是利用单调栈, 从0开始遍历题目数组, 栈维持着栈顶元素是最大的元素, 元素进栈的时候和栈顶元素比较, 如果栈顶元素小于当前元素, 这说明当前元素就是栈顶元素的下一个更大元素, 将栈顶元素弹出, 重复比较与弹出直至栈顶元素大于当前元素, 当前元素入栈, 重复这个过程.
  - 题目的变化 : 从下一个更大的元素, 变为对应元素的**第二大**的整数, 如果采用上面的思路, 我们只能获取第一大的整数, 同时不难发现, 这个时候每个元素需要被比较两次, 如果都被比较下去了, 第二次比较下去的元素就是我们的目标元素
  - 解决方案 : 构建一个<int,int>的stack, 第一个元素用于存储这个元素的第二大的元素的索引, 第二个元素用于存储这个元素被弹出的次数(被比较下去的次数), 那么弹出的时候需要分情况, 如果这个时候第二个元素(count)==0, 说明第一次被弹出, 在新的元素被放入单调栈中合适的位置后, 这个元素还需要再被放回stack, 所以会被先暂存入stack2用于未来将这个元素放回stack,  count == 1, 说明这个时候是第二次被弹出, 那么这个索引位置的元素已经找到了它对应的第二大元素, 将这个元素直接pop, 不再放入stack2用于复原

- code 
  ```cpp
  /*
   * @lc app=leetcode.cn id=2454 lang=cpp
   *
   * [2454] 下一个更大元素 IV
   */
  #include <iostream>
  #include <vector>
  #include <stack>
  #include <utility>
  using namespace std;
  // @lc code=start
  class Solution {
  public:
      vector<int> secondGreaterElement(vector<int>& nums) {
          vector<int> ret(nums.size(), -1);
          stack<pair<int,int>> st1, st2; // 第一个元素存储对应元素的索引, 第二个元素存储该元素出栈的次数
          // 遍历入栈
          for (int i = 0; i < nums.size(); i++) {
              // 入栈的时候和栈顶元素进行比较, 找到自己的位置, 然后push_back
              // 栈顶元素是最小元素
              pair<int, int> current(i, 0);
              while (!st1.empty() && nums[st1.top().first] < nums[current.first]) {
                  // 同时对弹出的元素做判断, 如果第二个元素是0, 则存入st2, 同时second++, 
                  if (st1.top().second == 0) {
                      st1.top().second++;
                      st2.push(st1.top());
                  // 如果是1, 说明已经出栈一次了, 存入目标数组ret
                  } else if (st1.top().second == 1) {
                      ret[st1.top().first] = nums[i];
                  }
                  st1.pop();
              }
              st1.push(current);
              // 将st2中的元素, 重新压入st1中, 将暂存的元素还给st1
              while (!st2.empty()) {
                  st1.push(st2.top());
                  st2.pop();
              }
          }
          // 最后清空栈 -> 不必要的操作, 因为默认值就是0
          return ret;
      }
  };
  // @lc code=end
  
  // @test
  int main() {
      Solution s;
      cout << "case 1 :" << endl;
      vector<int> nums = {2,4,0,9,6};
      cout << "ret : [";
      for (const auto& num : s.secondGreaterElement(nums)) {
          cout << num << ", ";
      } 
      cout << "]" << endl;
  
      cout << "边界条件的测试" <<endl;
      cout << "case 2 :" << endl;
      nums = {0};
      cout << "ret : [";
      for (const auto& num : s.secondGreaterElement(nums)) {
          cout << num << ", ";
      } 
      cout << "]" << endl;
  
      return 0;
  }
  
  ```

#### P20.[有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)

- 一句话题解 : 如果是左符号, 直接压入栈, 如果是右符号, 则首先判断栈中有无元素, 如果没有, 直接`return false`, 接下来判断栈顶元素是不是其对应的左符号, 如果是直接`pop()`, 如果不是则直接`return false`, 所有元素遍历完以后, 判断此时栈中还有没有剩余, 如果有`return false`

  - 加快速度 : 如果元素数量不是偶数, 必定无法匹配完全, 直接`return false`

- code

  ```cpp
  /*
   * @lc app=leetcode.cn id=20 lang=cpp
   *
   * [20] 有效的括号
   */
  #include <iostream>
  #include <stack>
  #include <string>
  using namespace std;
  
  // @lc code=start
  class Solution {
  public:
      bool isValid(string s) {
          if (s.length() % 2) return false;
          stack<char> st1;
          for (int i = 0; i < s.length(); i++) {
              char ch = s[i];
              if (ch == '(' || ch == '{' || ch == '[') 
                  st1.push(ch);
              else {
                  // 需要匹配的情况, 
                  // 这里如果遍历栈的时候, 右括号一个都没有匹配到左括号
                  // 说明已经出错, 匹配到了则双双弹出
                  if (st1.empty() || ((ch == ')' && st1.top() != '(') || (ch == ']' && st1.top() != '[') || (ch == '}' && st1.top() != '{')))
                      return false;
                  st1.pop();
              }
          }
          if (!st1.empty()) return false;
          return true;
      }
  };
  // @lc code=end
  int main() {
      Solution s;
      cout << "case : 1" << endl;
      string str = "()";
      cout << s.isValid(str) << endl;
      cout << "case : 2" << endl;
      str = "()[]{}";
      cout << s.isValid(str) << endl; 
      cout << "case : 3" << endl;
      str = "()[]{{}";
      cout << s.isValid(str) << endl; 
      cout << "case : 4" << endl;
      str = "()[]{}}";
      cout << s.isValid(str) << endl; 
      cout << "case : 5" << endl;
      str = "()[{(})]{}";
      cout << s.isValid(str) << endl; 
      return 0;
  }
  ```

#### P150. [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

- 一句话题解 : 

  - 如果是数字, 直接`push()`入栈, 如果是符号, 则取出栈顶的两个元素做运算, 并将结果再存入栈中

- 特性 :

  - 后缀表达式本身的设计就是为了能方便计算机线性的运算非线性的非线性运算的中缀表达式, 利用栈解决更像是模拟题
  - 需要特别注意的是, **中间结果的类型 : `long long`**, 这个是需要特别注意的点, 因为中间结果可能会超出int 

- code

  ```cpp
  /*
   * @lc app=leetcode.cn id=150 lang=cpp
   *
   * [150] 逆波兰表达式求值
   */
  #include <stack>
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  // @lc code=start
  class Solution {
  public:
      int evalRPN(vector<string>& tokens) {
          // 循环压入栈中, 数字则直接压入栈中
          // 如果是运算符, 取出栈顶的两个元素进行运算, 并将运算结果存回栈
          // 没有左右括号
          stack<string> st;
          for (string c: tokens) {
              if (c == "+" || c == "-" || c == "*" || c == "/") {
                  long long num2 = stoi(st.top());
                  st.pop();
                  long long num1 = stoi(st.top());
                  st.pop();
                  long long num3 = 0;
                  if (c == "+") 
                      num3 = num1 + num2;
                  else if (c == "-")
                      num3 = num1 - num2;
                  else if (c == "*")
                      num3 = num1 * num2;
                  else if (c == "/")
                      num3 = num1 / num2;
                  st.push(to_string(num3));
              }
              else
                  st.push(c);
          }
          return stoi(st.top());
      }
  };
  // @lc code=end
  int main() {
      Solution s;
      cout << "case 1 :" <<endl;
      vector<string> tokens = {"2","1","+","3","*"};
      cout << s.evalRPN(tokens) << endl;
  
      cout << "case 2 :" <<endl;
      tokens = {"4","13","5","/","+"};
      cout << s.evalRPN(tokens) << endl;
  
      cout << "case 3 :" <<endl;
      tokens = {"10","6","9","3","+","-11","*","/","*","17","+","5","+"};
      cout << s.evalRPN(tokens) << endl;
      
      return 0;
  }

## 关于cpp中的一些API和语法的记录

### string

- string和int之间的相互转化 : 将string => int : `stoi()` , 将int => string : `to_string()`

### pair

- 在`<utility>`库中

```cpp
// 创建
vector<pair<int,int>> pair_test;

// 构造与传值
pair<int,int> p = make_pair(1,2);
pair<int,int> p(1,2);

// 取出值
p.first;
p.second;
```

### vector

- 构造
  ```cpp
  // 默认构造：空 vector
  std::vector<int> v1;
  
  // 指定大小的 vector，元素默认值初始化
  std::vector<int> v2(5); // 5 个元素，值为 0（int 的默认值）
  
  // 指定大小和初始值
  std::vector<int> v3(5, 10); // 5 个元素，值为 10
  
  // 通过其他容器初始化
  std::vector<int> v4 = {1, 2, 3, 4, 5}; // 使用初始化列表
  std::vector<int> v5(v4.begin(), v4.end()); // 通过迭代器范围
  
  // 使用拷贝构造
  std::vector<int> v6(v3);
  ```

  