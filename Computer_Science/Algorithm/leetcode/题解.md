## 单调队列

### 核心

- 单调队列能在数组每个元素都只进出双端队列一次的前提下,  保持队头是原数组中的某个子序列中的最大或最小值, 并且能持续获取
- 特征
  - 队头的元素始终是整个对列中的最大(小)的
  - 可以从队头`pop_front`或者`front()`, 但是队尾既能`pop_back()`, 也能`back()和push_back()`
- 构建代码的核心
  - 窗口是怎么移动的, 如何标定窗口的起始位置, 一般来说存入队列的元素并不直接是数值, 而是下标, 这样有利于删头的时候判断当前元素是不是在窗口中
  - 什么时候删头 (删头一般是元素在窗口外面的时候的处理)
  - 什么时候输出, 即从队列中取出元素, 打印或存入最终的数组中
  - 什么时候去尾 (一般是添加新的元素的时候, 很难有变化)

### 滑动窗口

#### P239.[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

- 一句话题解 : 通过单调队列能实现, 每个元素只进出队列一次就能获取到窗口的最大(小)值

- code 
  ```cpp
  /*
   * @lc app=leetcode.cn id=239 lang=cpp
   *
   * [239] 滑动窗口最大值
   */
  #include <vector>
  #include <deque>
  #include <iostream>
  using namespace std;
  
  // @lc code=start
  class Solution {
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          vector<int> ret;
          deque<int> dq;
          for (int i = 0; i < nums.size(); i++) {
              // 删尾
              while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();
              dq.push_back(i); 
              if (i >= k-1) {
                  // 删除头部不属于目前窗口的内容
                  while (!dq.empty() && dq.front() <= i-k) dq.pop_front();
                  ret.push_back(nums[dq.front()]);
              }
          }
          return ret;
      }
  };
  // @lc code=end
  ```

#### P1438.[绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)

- 一句话题解 : 连续子数组其实就是一个个的窗口, 窗口end就是i, 窗口begin向后滑动的条件是窗口中出现了超过限制的数, 一直滑动到正常为止, 这样的解法保证了每个元素只进出窗口一次, 需要特别注意的是这种解法的**边界条件** : 计算length的时机, 如果只是在出现了超过限制的数的时候计算, 就会出现如果最长子数组是窗口滑动到最后出现的, 这种情况因为没有超过限制是不会计算的, 并且这种时候length = end - begin + 1, 其他时候应该是length = end - begin 

- code
  ``` cpp
      int longestSubarray(vector<int>& nums, int limit) {
          deque<int> max_dq, min_dq;
          int length = 0;
          int begin = 0;
          for (int i = 0; i < nums.size(); i++) {
              // max的去尾
              while (!max_dq.empty() && nums[i] < nums[max_dq.back()]) max_dq.pop_back();
              max_dq.push_back(i);
              // min的去尾
              while (!min_dq.empty() && nums[i] > nums[min_dq.back()]) min_dq.pop_back();
              min_dq.push_back(i);
              
              // cout << "begin : " << begin<< ", end : " << i;
              if(abs(nums[max_dq.front()]-nums[min_dq.front()]) > limit) {
                  length = max(length, (i-begin));
                  // cout << "  计算了length";
                  while ((begin <= i) && abs(nums[max_dq.front()]-nums[min_dq.front()]) > limit) {
                      begin++;
                      while (max_dq.front() < begin && !max_dq.empty()) max_dq.pop_front();
                      while (min_dq.front() < begin && !min_dq.empty()) min_dq.pop_front();
                  }
              }
              if (nums.size() - i == 1) {
                  length = max(length, (i-begin+1));
              }
              // cout << ", length : " << length << endl;
          }
          return length;
      }
  };
  // @lc code=end
  int main() {
      Solution s;
      cout << "case 1 : " << endl;
      vector<int> input = {10,1,2,4,7,2};
      int limit = 5;
      cout << s.longestSubarray(input, limit) <<endl;
      cout << "case 2 : " << endl;
      input = {8,2,4,7};
      limit = 4;
      cout << s.longestSubarray(input, limit);
      return 0;
  }
  ```

### 最大子序和❓

- 题目 : P53.[最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

- 用单调队列优化DP, 但是还没学到DP还有前缀和, 所以搁置

 