# 基本思路

## 核心思路

相向双指针应用的题目满足以下几个特征
- 区间内的数是有序排列的
    - 由数组的有序性, 那么如果left + right < target, 这个时候无论怎么移动向左移动right都无法找到答案, 这个时候只有向右移动left才能找到答案, 故left++, 反之亦然
- 移动一边以后, 能明确在移动后会更接近还是远离答案, 也算是一种单调, 滑动窗口其实可以看作是一种特殊的双指针, 它的条件是需要根据在连续区间内判断才是有效的

满足条件以后, 就可以试着使用相向双指针解决问题

1. 创建左指针和右指针, 分别指向数组的两端
2. 对条件进行判断, 得出是left++, 还是right--, 或者left++且right--
3. 在条件符合的时候处理答案
4. 在left >= right 的时候退出循环

## 复杂度分析

时间复杂度 : 排序 $O(nlog_2n)$, 双指针遍历 $O(n)$, 综合来看 $O(nlog_2n)$

# 模板代码

```cpp
int left = 0, right = nums.size() - 1;
while (left < right) {
    int s = nums[left] + nums[right];
    if (s == target) {
        return  {left, right};
    }
    if (s > target) {
        right--;
    }
    if (s < target) {
        left++;
    }
}
```

## 常见优化

# 模板补充

> 关于两数之和的衍生 -> 三数之和 [[2. 三数之和]]

可以将三数之和问题转化为两数之和问题, 只需要简单的遍历第一个数, 对于这个剩下的两个数"两数之和", 找到满足条件的情况
- 时间复杂度 : 双层遍历, 时间复杂度 $O(n^2)$

## 对于三数之和问题的常见优化

- 如果对于当前选定的i而言, 剩下的数组中, 最大的两个数相加都小于target, 则continue, 因为还有增大的可能, 可能会发现满足的情况
- 如果对于当前选定的i而言, 剩下的数组中, 最小的两个数相加都大于target, 则break, 因为没有减小的可能, 剩下的所有i都不会满足== target的条件

# 相关资料

- 03xf的视频