# 题目说明

给你一个正整数数组 `price` ，其中 `price[i]` 表示第 `i` 类糖果的价格，另给你一个正整数 `k` 。

商店组合 `k` 类 **不同** 糖果打包成礼盒出售。礼盒的 **甜蜜度** 是礼盒中任意两种糖果 **价格** 绝对差的最小值。

返回礼盒的 **最大** 甜蜜度_。_

**示例 1：**

```
输入：price = [13,5,1,8,21,2], k = 3
输出：8
解释：选出价格分别为 [13,5,21] 的三类糖果。
礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。
可以证明能够取得的最大甜蜜度就是 8 。
```

# 题解

> 这道题目 **没有做出来**

这道题目算是目前做过的最复杂的一道check类型的二分查找了

> 这道题目和[[2439. 最小化数组中的最大值]]是对称的题目, 属于最大化最小值

这道题目中的合法的值不再是连续的, 而是离散的, 这点在最初给我思考check函数的时候带来了很大的阻碍, 但是实际上这个问题是个伪问题, 我们完全可以将值就当成连续的值去处理, 最后会收束最大的那个合法的离散的值, 这个问题后面会详细说明

> 单调性

- d为至少甜蜜度, 也就是我们只需要最后计算出来的最大甜蜜度 >= d就行
随着d的增加, 能选取的糖的种类就会不断减小, 直至小于k, 而随着d的减小, 能选取的甜蜜度也会不断增加

> check函数

- check函数就是根据d来进行判定的, 计算当前d我们能选取的糖是不是 >= k, 如果大于等于k, 说明这个甜蜜度是 >= 我们最后的答案的, 是 "可行的" 甜蜜度, 反之就是不可行的甜蜜度

> 二分逻辑

根据check函数, 我们最后就会把left收束到 "可行的" 甜蜜度和不可行的甜蜜度的边缘, 这个时候, left在的甜蜜度就是最大的甜蜜度, 

> 现在还有个问题就是, 这个最大的甜蜜度是不是存在的价格差

反证法,  当我们找到一个最大的可行的甜蜜度d的时候, 如果选取到的最后的k个数字中, 不存在相邻的数字差值是等于d的, 那么这个序列对于甜蜜度d + 1也是适用的, 这和这是最大的可行的甜蜜度是矛盾的

> right代表的上界的值

其实很简单, 可以把问题等效成, 我们现在有一条长度为L = price.back() - price\[0]的路, 我们现在要向条路上插入k个路标, 路标能放在起点和重点上, 那么路标之间的间隔就是d, 我们现在要做的就是最大化这些路标间隔中的最小的间隔, 很明显, 我们最好的策略就是平均放置, 也就是我们向这条路中间插入(k -1)个路标的时候

# code

```cpp
class Solution {
public:

    // 甜蜜度至少为d是不是可能的
    bool check(vector<int>& price, int k, int d) {
        int cnt = 1;
        int pre = price[0];
        for (int p : price) {
            if (p - pre >= d) {
                pre = p;
                cnt++;
            }
        }
        return cnt >= k;
    }

    int maximumTastiness(vector<int>& price, int k) {
        sort(price.begin(), price.end());
        // 甜蜜度越高是不可能的, 所以left是蓝色, true
        int left = 0;
        // false
        int right = (price.back() - price[0]) + 1;
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            (check(price, k, mid) ? left : right) = mid;
        }
        return left;
    }
};
```

# 复杂度分析

- 时间复杂度 : $O(klog_2U)$ , 其中k是糖果的种类, U是$\lfloor (p_max - p_min) / (k - 1) \rfloor$
- 空间复杂度 : $O(1)$, 只使用了常数个额外空间