# 题目说明

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须尽可能减少整个过程的操作步骤。

**示例 1：**

```
输入：nums = [1,3,5]
输出：1
```

**示例 2：**

```
输入：nums = [2,2,2,0,1]
输出：0
```

# 题解

> 这道题是[[153. 寻找旋转排序数组中的最小值]]的变式, 添加了数组中的元素是可以相同这个条件

- 产生的影响, 如果nums\[mid] == nums.back(), 无法判断这个元素是在左半区还是右半区,
- 怎么解决? 
    - 记录右边有多少个重复的数字, 只有在nums\[mid] > end && mid < repeat的时候才是在左半区, 否则在右半区

# code

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        // 末尾的元素
        int end = nums.back();
        int repeat = nums.size() - 1;
        while (repeat >= 1 && nums[repeat] == nums[repeat-1]) repeat--;
        // 最小值及最小值左边的元素
        int left = -1;
        // 最小值右边的元素
        int right = nums.size() - 1;
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= end && mid < repeat){
                left = mid;
            } else {
                right = mid;
            }
        }
        return nums[right];
    }
};
```

# 复杂度分析

- 时间复杂度 : $O(n)$, 最差的时间复杂度发生在数组中的所有元素都是一样的元素的时候, 这个时候我们的repeat会执行n次
- 空间复杂度 : $O(1)$, 我们只使用了常数个额外空间