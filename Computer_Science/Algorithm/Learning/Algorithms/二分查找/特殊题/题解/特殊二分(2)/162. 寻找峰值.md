# 题目说明

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

# 题解

> 这道题可以说算是独立出check体系的另一类题目了, 交集类题目

很怪的一类题目, 但是确实能用二分查找去处理

> 单调性

这道题目严格来说是没有单调性的, 这道题目如果有单调性, 就应该是对于位置x, 如果我们判断了x的右边存在峰值, 那么x左边的元素判断的峰值的时候都是在右边存在峰值, 但是很显然这是错误的

> 二分答案

这道题更接近二分的本质 : 我们能一次性将答案区间缩小1/2
- 我们能通过比较当前元素和临近元素的大小, 得出来, 大的那一边, 一定存在一个峰值(最极端的情况就是左边界和右边界是峰值的时候), 通过这样不断的比较, left及其右边一定会存在一个峰值, right的左边一定存在一个峰值, 那么最后的时候left的值就是峰值在的位置
# code

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        // true , 峰值及左边的元素
        int left = 0;
        // false , 峰值右边的元素
        int right = nums.size();
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid - 1]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```

# 复杂度分析 

- 时间复杂度 : $O(log_2n)$
- 空间复杂度 : $O(1)$