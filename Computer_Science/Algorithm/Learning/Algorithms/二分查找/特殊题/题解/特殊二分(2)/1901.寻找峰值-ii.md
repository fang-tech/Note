# 题目说明

一个 2D 网格中的 **峰值** 是指那些 **严格大于** 其相邻格子(上、下、左、右)的元素。

给你一个 **从 0 开始编号** 的 `m x n` 矩阵 `mat` ，其中任意两个相邻格子的值都 **不相同** 。找出 **任意一个 峰值** `mat[i][j]` 并 **返回其位置** `[i,j]` 。

你可以假设整个矩阵周边环绕着一圈值为 `-1` 的格子。

要求必须写出时间复杂度为 `O(m log(n))` 或 `O(n log(m))` 的算法

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/06/08/1.png)

```
输入: mat = [[1,4],[3,2]]
输出: [0,1]
解释: 3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。
```
# 题解

> 首先这道题目我们得搞清楚怎么使用暴力方法来解决这个问题, 这样我们才能认识到 "我们该怎么找到答案"

## 暴力

由于题目中的性质, 每个元素和相邻的元素之间不可能会相等, 可以将这个山想象成是没有平台的山, 现在我们需要在这个山上找到局部最优解, 也就是峰顶(并非全局最优解, 和之前的一阶的寻找峰值是一样的) 

- 我们现在站在山上的某个位置, 如果我们要找到顶峰, 其实有个很直觉的找路方式, 看看四周, 有没有比现在高得地方, 然后 **人往高处走**, 我们只要一直沿着高走, 最后到了一个四周都比这个点低的地方, 这个地方就是局部最优解, 很像梯度下降
    - 将这个说法换算成代码, 就是检查现在的点四周有没有大于当前点的, 如果有就将curr替换成更大的点, 如果没有了, 说明这个点就是峰值, 返回这个局部的峰值
- 从任何一个点触发, 这么走一定能走到吗 ? 
    - 一定能走到, 因为这里就两种情况, 有更高处和没有更高处, 有更高处就是进入到另一个子情况

## 二分查找

搞清楚暴力的做法, 也就是找到局部最优解的简单方法, 有没有更快的做法 ? 在哪里我们能够使用二分和找到单调性

> 单调性

我们现在找到某一行的最大值x, 索引是i, j, 那么这个时候我们可以通过比较这个最大值元素和该行的下一行元素i + 1, j之间进行比较, 如果当前元素大于下一行的元素, 说明峰值出现在该行的下面, 反之则出现在这行或者这行上面

> 为什么我们一定要选取最大值

- 只有最大值才能保证单调性
- 现在我们想象有一条路径通往峰顶, 现在我们站在X的位置, X是这行的最大值, 我们现在通过这行将区域分为这行及以上, 这行以下
    - 如果X比下一行的元素大, 这个时候下半区一定有一条通往峰顶的路径, **同时, 因为X是这行最大的元素, 所以路径不会穿过这一行, 也就是最后的峰顶也一定在下半区**, 因为接下来的路径中的值都是一定 > X的, 但是X是这行中的最大的元素, 所以最后的路径一定不包含这行中的其他元素
    - 反之亦然

> 最后的返回值的第二个索引indexOfMax(mat\[right])

- 因为这个值一定是峰值, 这个值肯定大于上面的行的所有值, 并且肯定大于两边的值, 同时通过了比较
- 同时根据right的性质, 我们可以知道mat\[right]\[i] > mat\[right]\[i]所以也大于下面一行对应位置的值 
- 通过left在上面, 得出来这个元素的上面的元素一定小于这个元素, 通过right的下面, 的出来这个元素的下面的元素一定小于这个元素
# code 

```cpp
class Solution {
public:
    int indexOfMax(vector<int>& line) {
        return max_element(line.begin(), line.end()) - line.begin();
    }

    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        // 该行及以上存在峰值
        int right = mat.size() - 1;
        // 该行以下存在峰值
        int left = -1;
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            int i = indexOfMax(mat[mid]);
            if (mat[mid][i] < mat[mid + 1][i]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return {right, indexOfMax(mat[right])};
    }
};
```

# 复杂度分析

- 时间复杂度 : $O(mlog_2n)$ , O(m) 是每次查找当行的最大元素的开销, O(log_2n) 是二分查找包含答案的那行的开销
- 空间复杂度 : $O(1)$, 只使用了常数个额外空间