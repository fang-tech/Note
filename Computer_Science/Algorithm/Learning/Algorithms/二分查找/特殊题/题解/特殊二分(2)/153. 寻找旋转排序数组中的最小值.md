# 题目说明

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

# 题解

> 这道题目和[[162. 寻找峰值]]一样, 都是我们能确定答案一定在我们现在mid的某一侧的题目, 虽然这道题目其实是更能满足单调性的, 算是满足了单调性了的, 但是这里的单调性我就不再赘述

> 题目逻辑

选定数组最右边的元素, 那么这个元素要么是最小值, 要么是在最小值的右侧, 我们这个能通过和这个最右边的元素进行比较, 得出来某个元素与最小值的位置关系
- 如果这个值 > 最右侧的值x, 那么说明当前值肯定不是最小值, 并且这个值在最小值的左侧, 因为从最小值到这个最右侧的值这个区间范围内, x是最大的值, 如果这个值都大于了这个最大的值说明这个值肯定是在左边的区间的
- 如果这个值 <= 最右侧的值, 说明这个值是最小值或者最小值的右侧

# code

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        // min的左边
        int left = -1;
        // min及min的右边
        int right = nums.size();
        int x = nums.back();
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > x) // 同时说明了mid位置的元素一定不是最小值
                left = mid;
            else   
                right = mid;
        }
        return nums[right];
    }
};
```

# 复杂度分析

- 时间复杂度 : $O(log_2n)$
- 空间复杂度 : $O(1)$