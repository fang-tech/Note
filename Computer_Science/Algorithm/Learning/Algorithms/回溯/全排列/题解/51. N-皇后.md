# 题目说明

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

**提示：**

- `1 <= n <= 9`

# 题解

> 首先, 为什么这道题目会被划在全排列问题当中, 答案也很显然, 我们能够将这个问题转化成全排列问题

## 全排列

题目有第一个对于皇后位置的约束 : 所有的皇后都在不同行不同列, 并且我们有n个皇后, 在一个n\*n的矩阵中

- 这个条件能够转化为 : 每行每列都有一个皇后
    - 证明 : 我们有n个皇后, n行n列, 同时每个皇后不能在同行同列, 说明每行每列都有一个皇后
    - 所以我们可以使用一个col\[j]数组, j就是皇后行号, col\[j]就是皇后列号, 我们就能通过一个数组, 记录所有皇后的位置, 使用这种方式能保证每行每行都有一个皇后
    - 现在我们要求皇后的所有可能的位置组合就变成了给这个col数组全排列
- 现在我们再加上第二个约束 : 一个皇后的斜线位置不能有另一个皇后
    - 观察一条斜线上的所有点的坐标, 我们很容易发现, 对于一条上斜的斜线, 我们r + c是定值. 对于一条下斜的斜线, 我们 r - c是定值
    - 所以我们可以通过r + c和r - c来记录现在那些斜线上是有皇后的, 在全排列的时候只有我们遍历到没有被选过的值, 并且这个节点所在的对角线没有皇后才能将这个节点添加到答案中

> 因为r - c是有可能 < 0 的, 比如绝对值最大的(1,4), 这里的r - c == -3, 所以我们需要让这个最小的r - c能映射到0索引, 最小的r - c应该能 1 - n, 所以我们在记录的时候需要 + n - 1. 同时因为这样的映射, 我们还需要保证最大的r - c不会出现数组越界, 最大的r - c == n - 1, 所以我们最大的r - c在映射以后的索引是n - 2, 所以我们申请的数组的大小应该是n - 1

# code

```cpp
/*
 * @lc app=leetcode.cn id=51 lang=cpp
 *
 * [51] N 皇后
 */

#include <string>
#include <vector>
using namespace std;
// @lc code=start
class Solution {
public:
    vector<vector<string>> ans;
    vector<int> col; // 全排列数组
    bool diag1[20]; // 记录所有已经出现过的r+c, 用于判断是不是在上斜对角线
    bool diag2[20]; // 记录所有已经出现过的r-c, 用于判断是不是在下斜对角线, 
                    // 因为会出现负数, 比如r = 1, c = 2, 同时需要将正数和负数区别开来, 所以计算出来的 + n - 1
    
    bool on_path[10]; // 记录这个数字有没有被选过

    void dfs(int n, int i) {
        if (i == n) {
            // 添加答案
            vector<string> path;
            for (int r = 0; r < n; r++){ // 第r行
                string s;
                // 添加.
                for (int i = 0; i < col[r]; i++) {
                    s += '.';
                }
                // 添加上Q
                s += 'Q';
                // 继续添加.
                for (int i = 0; i < n - col[r] - 1; i++) {
                    s += '.';
                }
                path.emplace_back(s);
            }
            ans.emplace_back(path);
            return;
        }

    // 从n个数中, 选下一个数字
    for (int j = 0; j < n; j++) {
        // 没有被选过才能选, 并且对角线上没有元素
        if (!on_path[j] && !diag2[i-j+n-1] && !diag1[i+j]) {
            // 第i行, 第j列, 有皇后
            col[i] = j;
            on_path[j] = true; // 第j个数字我们已经选过了
            diag2[i-j+n-1] = true; diag1[i+j] = true; // 记录对角线已经选过了
            dfs(n, i+1);
            on_path[j] = false; // 恢复现场
            diag2[i-j+n-1] = false; diag1[i+j] = false; // 记录对角线已经选过了
        }
    }
    }

    vector<vector<string>> solveNQueens(int n) {
        col.resize(n);
        dfs(n, 0);
        return ans;
    }
};
// @lc code=end
```

# 复杂度分析

- 时间复杂度 : $O(n^2*n!)$, n!是遍历所有节点的时间复杂度, 在最后的叶子节点中记录答案的时间复杂度是n
- 空间复杂度 : $O(n)$, 返回值的空间不计入