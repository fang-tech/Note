# 0/1背包问题举例

## 问题描述

现在我们有N个物品, 每个物品有价值V[N]和体积W[N]两个参数, 我们还有一个容量为C的背包, 我们现在需要知道, 背包里可以装的最大价值

## 自底向上和递推制表

### 问题分析

1. 对于问题的拆解 : 问题的最终答案很明显受到两个维度的参数的影响 : 物品和背包的容量, 我们可以将问题更小的子问题
   - 我们有前i个物品和一个容量为j的背包, 现在背包里可以装的最大价值

2. 子问题的最优解能否组成母问题的最优解 ?
   - 对于第i个物品, 有两种情况, 放的进去和放不进去(即物品的体积大于背包现在的容量j的时候)
     - 放不进去 : 这个时候dp\[i][j] = dp\[i-1][j]
     - 放得进去 : 放和不放, 取其中的最大值, 如果放这个时候的值则为子问题前i-1个物品容量为j-W[i]的子问题的最优解+V[i],
   - 综上, 得出来的状态转移方程为 :  dp\[i][j] = max(dp\[i-1][j], dp\[i-1][j-W[i]]+V[i])

3. 初始化

   - 需要初始化的点为 : dp\[0][...], dp\[...][0],  即选用前0个物品和容量为0的时候, 这两种情况下的价值都为0

4. 代码

   ```cpp
   dp[N][N];
   
   for (int i=1;i<=n;i++) {
       for (int j=1;j<=m;j++) {
           if (W[i] > j) dp[i][j] = dp[i-1][j];
           else dp[i][j] = max(dp[i-1][j], dp[i-1][j-W[i]]+V[i]);
       }
   }
   ```

## 自顶向上与记忆化

###  问题分析

- 与上面一样,只是将容量和前i个物品作为参数传递, 初始化情况直接`return 0`

- 代码

  ```cpp
  dp[N][N] = INF;
  
  int package(int i, int j) {
  	if (dp[i][i] != INF) return dp[i][j];
      if (i == 0||j == 0) {dp[i][j]=0; return dp[i][j]}
      if (W[i] > j) return package(i-1,j);
      else return max(package(i-1,j), package(i-1,j-W[i])+V[i]);
  }
  ```

- 逻辑是没有问题的, 就是因为递归的时间问题, 貌似会超时, 很奇怪, 建议还是不用递归处理问题

