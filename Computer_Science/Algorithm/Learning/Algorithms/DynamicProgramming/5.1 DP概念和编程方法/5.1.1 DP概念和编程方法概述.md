# DP概念和编程方法概述

## 概念

- DP -> Dynamic Programming 动态表格法, 动态规划
- 本质上和搜索极像, 或者说, 其实DP在最原本的定义上, 就是记忆化的搜索
  - 搜索是将所有情况遍历完全(最暴力的情况), 这种时候, 计算机遍历的路径中很容易走了重复的路径
  - 这样重复的走, 大幅增加时间复杂度, 所以很容易想到的一种解决方法就是, 记忆化
  - 将走过的路径的结果记录下来, 下次再走到这个地方的时候, 如果走过了, 就直接从那个记录路径结果的表格中取值就行, 而不用再重新走一遍
  - 这实际上就已经是DP了, 只不过, 我们这里很明显还有需要约束和更进一步的分析的地方
    - 约束条件 : 这条路径对应的值不依赖于是怎么访问到这条路径的. 也就是无后效应
    - 分析 : 并不是所有情况都能够记忆化, 因为这个表格能不能构建和构建以后对于问题的简化程度, 构建表格的可操作性都是需要靠量的, 这里我们需要考虑的是, 这个问题, 是不是一个最优子结构问题

### 最优子结构

- 首先这个问题是一个能由子问题组成成母问题的问题, 即母问题其实是由规模更小的若干子问题组成, 但这里其实也只是满足了子结构, 因为这样的组合虽然能产生一条路径, 但是我们往往需要的是最优的路径
- 最优 : 再加上限制, 母问题的最优解由子问题的最优解组成

### 对于无后效应的补充

- 子问题当前解的最优性是不会被母问题所影响的

## DP的最优的完备性

通过以上分析和约束, 我们能证明最终通过DP得到的答案是最优的是完备的, 而不是像贪心一样的局部最优解

- 在问题的结构上, 是母问题的解可以由子问题组合而成
- 同时母问题的最优解能由子问题的最优解组合而成
- 母问题的变化并不会导致子问题的最优解发生变化(无后效应), 子问题的最优解只与子问题和其子问题本身影响, 独立于母问题

## DP的编程方法

其实根据上面的分析, 大概也能得出来DP的分析和编码步骤, 这些步骤会在后续对于题目的分析中反复, 以分析题目和明确做法是否是正确的 

### 分析步骤

1. 将原问题分解为母问题的最优解能由子问题的最优解组合而成的问题形式 (翻译问题)
2. 子问题的最优解如何组合才能得到母问题的最优解

### 编码步骤

和搜索一样, DP也有两种编码形式 : 自顶向下(递归)和记忆化, 以及自底向上(递推)和制表, 一般常用制表递推, 这里指的是完成编码的一般顺序, 并不是代码在文件中实际的上下顺序

### 制表递推

1. 明确DP的状态方程, 创建DP数组 => 即对应分析步骤中的第一步, 将问题描述为能由子问题的最优解组成母问题的最优解的形式
2. 编写状态转移方程  => 即子问题的最优解是如何组合成母问题的最优解
3. 对于DP状态的初始化

### 记忆化递归

1. 明确DP的状态方程, 与上面的创建数组相比, 这里是传递的参数是DP的状态方程
2. 递归中母问题是是怎么由子问题的返回的数值组成
3. 设定"最子"的问题, 用于返回
4. 如果这个地方被访问过, 直接返回记忆表格中的值
