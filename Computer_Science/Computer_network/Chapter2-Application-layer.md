# 应用层

## 2.1 应用层原理

C/S 结构

- 不对等的结构, S是核心

- 随着用户的增加, 达到一定阈值后, 性能会有断崖式的下降

P2P 结构 -> 对等体

- 关系是对等

- 随着用户的增加, 性能会能够维持

混合结构

- 举例说明

  - 注册, 目录等是集中式的

  - 用户的之间的通信是对等的

- 在对等体的某次通信中, peer可能是充当服务端, 也可能充当客户端

- 分布式应用进程需要解决的问题
  - 问题一 : 进程标识 (用于标识你的是唯一的, 这样能保证不会发送错位置), 寻址 (别人该怎么找到你, 相当于找到你的住房的地图)
  - 问题二 : 应用层的下层传输层是怎么提供服务的, 从而使应用层之间可以传输信息
  - 问题三 : 怎么定义报文的形式, 接到报文后的行为 -> 协议
- 寻址一个应用进程的三个要素
  1. IP地址
  2. TCP还是UDP
  3. TCP或UDP的端口号

- 需要传递的信息
  - 发的什么
  - 谁发的
  - 发给谁
- 为了减少层间的信息传输数量, 我们引入了socket, 它在计算计上的物理体现就是一个整数
  - 对于TCP : 就会创建一个整数用于映射 (我的主机ip, 端口号, 对方的主机ip. 端口号) 这个四元组
  - 对于UDP : 就是一个(对方的IP, 进程端口号) 这个二元组
  - 这里的机制类似于C语言中传输大型的struct, 比起将整个struct传输进去, 我们更倾向于传输一个地址, 通过这个简短的地址, 我们就能找到那个大的变量
  - 接下来的收发, 我们都只用传递那个socket值
- TCP socket : 用于指明应用进程会话的本地显示
- UDP socket : 仅代表一个端节点, , 是无连接的, 发送的内容里就必须有对方的ip和端口号

- 应用对于协议的选择的四个考量因素
  - 数据丢失率
  - 安全性
  - 吞吐
  - 延迟
  - 举例说明
    - 文件传输 -> 数据不能有丢失, 对吞吐需求不大, 延迟同样, 安全性可能有要求
    - 交互式游戏 -> 对延迟敏感, 容忍丢失, 吞吐量小
    - 直播 -> 容忍丢失, 对吞吐量的要求高, 同时延迟不能超过0.1s
    - 实时电话 -> 容忍丢失, 对吞吐量要求较高, 延迟要求同上
    - 

- TCP和UDP都是明文传输, 对于安全性没有任何的保证

## 2.2 Web and HTTP : port = 80

### URL

- Uniform Resource locator 统一资源定位符

- 格式 : Prot(协议名) : //user:psw@www.someSchool.edu(主机名)/someDept(路径名)/pic.gitf:port(端口, 因为Web引用有默认的端口号, 一般端口号不需要指定) 

### HTTP协议

#### 非持久化的HTTP连接

- 非持久化的连接的通讯过程

  1. C -> S 请求建立连接 (TCP)

  2. S -> C 确认建立连接 (TCP)

  3. C -> S 请求对象 (HTTP)

  4. S -> C 返回对象 (HTTP)

  5. C -> S  关闭连接 (TCP)

1. 响应时间模型
   - 往返时间RTT (round-trip-time) : 一个小的分组从客户端到服务器, 再从服务器返回客户端的时间, 因为分组很小, 传输时间可以忽略不计, 但需要记录传播时间
   - 故一次HTTP通讯, 需要耗费的时间为2 \* RTT + 对象的传输时间
   - 第一个RTT 用来发起TCP连接, 第二个RTT 用来发起HTTP请求, 并等待HTTP响应

#### 持久化的HTTP连接

- 通讯过程

  	1. C -> S 请求连接 (TCP)

  2. S -> C 确认连接 (TCP)

  3. C -> S 请求获取对象 (HTTP请求报文)

  4. S -> C 发送对象 (HTTP相应报文)

  5. C -> S 请求获取对象2....

- 非流水线和流水线方式
  - 非流水线方式 -> uqi, 流水线方式 -> qi
  - uqi方式
    - 是一个对象一个对象获取的, 其中是有阻塞关系的, 下一对象的获取请求需要等待上一个对象获取完毕以后, 才会发送
    - 举例 : 
      C -> S 请求获取对象A
      S -> C 返回对象 A
      C -> S 请求获取对象B
  - qi方式
    - 分成两部分处理, 首先统一发送所有请求, 再一次接受所有的返回, 实现了并行的收发
    - 举例 :
      C -> S 请求获取对象A
      C -> S 请求获取对象B
      ...
      S -> C 返回对象A
      S -> C 返回对象B

#### 请求报文

- 请求报文示例 : 

```http
GET(请求方法) ..URL路径.. HTTP/1.1(协议)
Host: www.example.com	// 请求的服务器域名
User-Agent: Mozilla/5.0	// 客户端信息
Accpet: text/html,application/json // 客户端能接受的内容类型
Connetion: close		// 连接是否建立一次通讯后就关闭
Accept-Language: zh-CN	// 接受的语言偏好
Content-Type: application/json // 传输的内容的类型
Content-Length: 128		// 接下来的信息中属于该次请求的内容的长度
...
<Entity-data> // 请求携带的表单 
```

- 对于Content-Type的解释 : TCP协议是没有维护着边界数这个数据的, 所以需要更上层的协议或应用规定, 以此来区分在同一次的传输中的庞大内容中属于各自通讯的部分
  - 举例 : 我发送了两个HTTP请求, 各自的长度是15K, 则在TCP中, 一次性传输了30K的数据, 现在我们就需要这个Length划分边界, 以说明这部分内容是属于哪个请求的
- 提交请求相关的数据的方式 :
  - URL方式 : 在URL中写出 (RESTFUL), 例如 : tb.com?username=...&password=...
  - 表单方式 : 即提交请求中包含请求体, 常见的有json形式的表单
- 1.1新增的请求方法 : PUT (用于新增数据), DELETE (用于删除数据)

#### 响应报文

- 响应报文示例 :
  ```http
  HTTP/1.1 200 OK 
  Connection: close	// 控制连接状态, close表示服务器处理完请求后关闭连接, 
  					// 另一个值是 keep-alive
  Date:  Wed, 21 Oct 2024 07:28:00 GMT // 服务器发送响应
  Server: 	// 服务端的信息
  Last-Modified:	Wed, 21 Oct 2024 07:28:00 GMT // 用于更新缓存使用, 在接下来的缓存部分会详细说明, 这里显示的是资源最后修改的时间
  Contenet-Length: 	// 作用与请求报文中的一致
  Content-Type: 	// 响应报文的类型
  ```

#### cookies

1. 有状态和无状态
   - HTTP是无状态的协议, 服务器不会维护与客户端的通讯历史, 即每一次的交换报文, 都是一次全新的通讯
   - 带来的问题是, 在像电商平台这种网站上, 我们是有需要维护的状态的, 比如用户信息

- Cookie就像网站临时给的身份证, 帮助网站记住你是谁, 记住你的偏好设置, 一般会保存在浏览器的某个文件夹下
- 执行逻辑
  1. 第一次访问网站的时候, 请求是不会携带cookie的
  2. 服务器响应的返回中会携带Set-Cookie响应头
  3. 之后的请求中, 都会携带Cookie请求头 (来源于之前获得到的Cookie) 
- 举例说明 : (常用但典型的用户信息就不用说明了, 主要说明购物车场景) 
  1. 用户添加第一个商品到购物车的时候 , 请求 : POST / cart/add
  2. 服务器返回 : Set-Cookie: cart_id=123456
  3. 后续添加商品, 请求自动带上: Cookie: cart_id=123456

- Cookie与隐私 : 
  - 并不是所有的Cookie都是和上面介绍的一样, 是为了更便捷和传输更少的数据而服务的, 有相当一部分会采集用户的行为数据, Cookie可以算是存放浏览隐私数据的容器
  - 一般来说, Cookie是不会被跨站使用的

#### Web缓存

- 优点 : 

  1. 能降低返回的时间
  2. 减小服务器的负载

- Web缓存的两种方式

  1. 本地缓存 : 这个本质上应该算是加载静态资源, 并且保存在本地, 这样就能将以一些常用的数据, 比如Logo保存在本地, 而不是每次访问网站都需要重新获取

  2. proxy代理服务器方式 : 

     - 这种缓存方式更为复杂, 它的核心理念是 "二八定律" ,即80%的人访问了20%的内容, 所以我们可以设置一个服务器, 专门用于承载那个20%被经常访问的数据, 这样, 就不用所有的数据都需要走源服务器并且, 这样即使我们不用提高服务器的带宽, 同样能大幅提高响应速度

     - 举例说明 : 以搜索引擎为例, 原本我们收到所有的数据, 执行的逻辑都是发往源服务器, 再执行搜索, 但是这样会导致导向源服务器的数据量需要随着访问的增加, 一直线性地增加, 这样对于带宽的需求变得极大. 

         解决方案 : 将设置proxy服务器, 用于做中间的代理, 其中直接存储了那20%的数据, 则访问者的数据如果 "hit" 中了这20%, 则会走浏览器 -> 代理服务器, 而不会加重源服务器的负担

  3. 缓存与Last-Modified以及If-Modified-since字段之间的关系

     - 本地缓存 : 更加直接, 如果请求头中的If-Modified-since字段和Last-Modified字段的中的时间戳不同, 则会更新本地的数据, 不同时候, 这个请求会返回200, 而在相同的时候则会返回304 Not Modified

     - proxy代理缓存 : 会变成如图所示的访问路线
       ```
       C  ->  proxy  ->  S
        |       |      |
        |-请求-> |      |
        |       |-验证请求->|
        |       |<-304响应-|
        |<-304响应-|      |
       ```

     - 那两个首部行的内容都是timestamp -> 时间

## 2.3 FTP : port 21, RFC 959

- 用于早期的文件共享, 但因为是明文的传输, 后面应该是被替代了的

- 以TCP作为传输协议


#### 通讯流程 

1. 建立TCP连接 : **21端口 -> 控制连接**
2. 身份认证 (用户名, 密码, ...)
3. C端向客户端发送控制指令查看文件list
4. 接收到要下载文件的指令, 服务器打开另一个到客户端的20端口的连接, 用于数据传输
5. 一个文件传输完毕以后, 关闭数据连接

#### 特性

- 是带外  ( out of band ) 传送
- FTP协议是有状态的, FTP服务器需要维护用户的状态信息, 当前路径, 用户账户与控制连接对应

#### 命令与响应 : (响应不赘述, 有需要时自行查找)

- USER username
- PASS password
- LIST 请服务器返回远程主机当前目录的文件列表
- RETR filename 从远程主机当前下载文件
- STOR filename 向远程主机上传文件

## 2.4 SMTP : port 25

#### Email的组成

1. 用户代理 : 
   - 一般是用户的C端, 比如, Gmail就是我和谷歌邮箱服务器之间的用户代理, 使得通讯的过程可以被隐藏而变成面向最终用户的操作端
2. 邮件服务器 : 用于收发邮件
3. 简单的邮件传输协议 : SMTP
4. 邮件访问协议 : POP3, IMAP, HTTP

#### 邮件的收发的过程举例说明 (A 要向 B发送邮件)

1. 发送邮件(SMTP) : A 通过用户代理 -> 邮件服务器a
2. 发送邮件(SMTP) : A发送的邮件被邮件服务器a -> 邮件服务器b

3. 接受邮件(POP3...) : B 通过用户代理从服务器b拉取邮件A

#### SMTP协议特性 : 

1. message全部内容都必须是7位的ASCII码, 不遵从这个规定是无法传输的
2. 是持久连接, 并不是发送了一个邮件就会关闭, 一个TCP连接可以发送多个邮件
3. 报文内容用CRLF做结尾符
4. 一次传输的报文里, 是可以有多个对象的, 比如, 我这封邮件里有正文, 还有我的附件, 都会一同传输

#### 文本报文 :

-   RFC 822 : 文本报文标准
- 首部行 : 
  - To : 收件人
  - From : 发件人
  - Subject : 

- 现在就有问题是, 如何只通过ASCII码传输所有内容, 比如有中文, 很容易会出现在ASCII码编码内容之外的内容
  - 解决方法 : 做映射编码, 常见的方式有Base64编码模式

#### 邮件访问协议

我们发送了邮件以后, 另一个人还需要收到和查看邮件, 这个时候就需要用到邮件访问协议

- 常用的协议 : 均为明文协议

  - POP3 : 较简陋的协议, 仅支持本地管理文件夹
  - IMAP : 对比POP3更复杂, 是有状态的协议, 支持远程管理文件夹

  - HTTP : 易用

##### POP3协议

**无状态**

通讯过程 : 

	1. 用户确认阶段
	- 用户名
	- 密码
	2. 服务器响应
	- +OK
	- -ERR
	3. 事务处理阶段 (拉取邮件的阶段)
	- 客户端 -> 服务器
	- list -> 获取报文号列表
	- retr 报文号 -> 拉取对应报文号的报文
	- dele 报文号 -> 删除对应的报文
	- quit -> 关闭连接

##### 下载并删除与下载并保留

- 下载并删除 ->  将邮件下载到客户端以后, 会将服务器上的邮件dele
  - 能减小服务器的负载
  - 如果改变了客户机, 就不能阅读邮件了
- 下载并保留 -> 留在云端, 即使下载到本地后, 也不会删除
- POP3的默认模式是下载并删除, 但是也可以通过设置DELE标志为false, 使得下载并保留

##### IMAP

**有状态**(会话状态, 邮件的状态和标记, 目录的访问权限)的协议, IMAP服务器会将每个报文和一个文件夹关联起来, 这样就能构建一个远程的文件系统

, 并通过这个远程的文件系统, 远程的管理邮件

- 允许用户通过目录组织访问
- 允许用户之拉去报文的组件 (只拉取报文的一部分, 比如我只获取这个封邮件中的附件)
- 在会话过程中始终保持用户状态, 会维护持续的会话状态, 而POP3每一次的连接都是新会话
  - 用户名, 邮件ID和目录之间映射

## 2.5 DNS

提供域名, 并做域名到IP地址之间的转换

- 如何命名设备

  - 平面化会有重名
  - 分层式的命名

- 如何做转换

  - 不可能由一台设备集中式解决, 不可行
  - 分布式的解析

- 对域名的管理, 对域名的维护问题

  - 对域名的增删

- DNS

  - 除了能提供域名到IP地址的转换, 还有别名到规范名字的转换
  - 能做到负载均衡

- 问题一 : 层次化树状的结构的命名方法

  - Internet根被划分为几百个顶级域

    - 通用的(generic)

      .com; .edu; .gov; .int; .mil; .net .... 

    - 国家的(countries)

      .cn; .us; .nl; .jp

  - 根据这种划分方法, 最末端的树叶就是一台主机, 而每条树枝都是一个子域

  - 有13个根名字服务器

  - 域名是从树叶往上走, 用逗点间隔

  - 域的划分是逻辑的, 不是物理的

- 分布式解决

  - 一个名字服务器的问题 

    - 可靠性 : 单点故障

    - 拓展性 : 通信容量
    - 维护问题 : 远程维护集中的服务区

  - 将命名空间划分为若干区域zone

  - 权威

  - TLD服务器 : 顶级域服务器 : 负责顶级域名和所有国家级的域名

  - 区域名字服务器维护资源记录

    - Domain_name : 域名
    - ttl : time to live  生存时间
      - 可以是长期的 -> 权威记录, 长时间保持不变的记录
      - 也可以短期的 -> 缓存记录, 缓存下来某个域名和ip之间的对应关系, 缓存 -> 性能, 删除 -> 一致性, 这个对应关系是可能会发生变化的
    - Class : 类别, 互联网中所有都是IN (internet)
    - Value : ip地址
    - Type : 
      - 现在还需要关注提供的服务还有, 机器别名到正规名字的转换, 邮件服务器别名到正规名字的准换 , 域名到IP之间的转换, 下面的子域是怎么划分的
      - DNS的资源记录(RR)
      - RR的格式 : (name, value, type, ttl)
      - Type = A : Name -> 主机的名字, Value -> IP地址
      - Type = NS  : Name -> 域名, Value -> 域名对应的权威服务器的域名
        - 用于供上层域找到下层域, 那么就携带两组信息
          - 子域的命名, 权威服务器的命名
          - 权威服务器的IP
      - Type = CNAME : Name为规范名字的别名, Value为规范名字
      - Type = MX : Value为name对应的邮件服务器的名字

- DNS (Domain Name System) 工作流程

  1. 应用 -> 解析器 (resolver)

  2. 解析器作为客户 -> Name Server发出查询报文(UDP)
  3. Name Server返回响应报文 (name/ip)

- 递归查询, 从叶向根逐步走

- 迭代查询

- DNS 请求和响应

  - 其中的id用于统一查询和应答 

- 维护 -> 新增一个域

  - 简单来说, 就是上层服务器维护一个指针(资源记录的一个组合)

  - 举例, 我现在要新增一个uptopic.com的域名

    1. 到注册登记机构注册域名uptopic.com

    2. 向该机构提供权威DNS服务器 (基本的, 辅助的) 的名字和IP地址

    3. 登记机构在com  TLD服务器插入两条RR记录

       (uptopic.com, dns1.uptopic.com, NS)
       (dns1.uptopic.com, 212.212.212.1, A)

  - 在权威服务器中保有

    - 用于web的类型为A的记录
    - 用于邮件服务器的类型为MX的记录

- DNS泄露


## 2. 6 纯P2P架构

- 非结构化P2P
  - 将peer视作一个节点, peer和peer之间的会话视作一条边, 那么非结构化的P2P, 则以刚刚的方法构建出来的图是没有任何结构的, 是一个松散的, 随机的图
- DHT结构化的P2P
  - 采用刚刚的构建方式, 最后构建的图, 形成了树, 环等结构

- P2P: 集中式的目录
  - peer节点上线后, 向目录服务器提供ip和自己拥有的资源的目录
  - peer可以通过目录服务器检索和找到该去哪下文件

- 完全分布式 :
  - 泛洪式查询 (flooding), 不断向邻居发起查询, 邻居也向它的邻居发送查询
  - overlay覆盖式网络的维护
    - 上线 : 上线后, 通过客户端提供的在线的ip发出ping, 收到的节点返回response, 从而建立起了邻居关系
    - 下线 : 下线的时候, 向它的邻居发送请求说明自己下线, 邻居再随机获取一个节点作为节点以维持网络强度
- 混合体 : 存在组长和组员

- P2P文件分发 : BitTorrent
  - 将一个文件和一组描述以及hash值关联
    - 描述用于索引, hash值用于唯一标识文件以定位文件
  - 和完全分布式类似, 上下线建立洪流的方式相同
  - 采用bit map的方式
    - 假设现在我有诺干个文件块每个256k, 为其建立散列表, 每个peer维护一个bit map, 具有的文件标识为1, 其余的为0
    - 现在加入了一个新的用户, 这个用户的bit map就全部为0, 这个时候, 开始会随机地向其他节点请求, 在获取四个块之后, 后续就只会请求稀缺的块, 来防止拥有稀缺快的用户下线后, 其他用户难以获取这些稀缺的块
    - 并且对于一个peer, 它的下载的优先级, 会按照它对这个洪流的贡献分配
    - 现在有80个人向A发起下载请求, A不可能全部都满足, 他在前两个周期, 会只去查看在之前为他提供了更大贡献的节点发起的请求, 第三个周期会随机获取队列中的节点, 提供一个振荡的机会

- 结构化的P2P系统
  - 为每个内容计算哈希
  - 按照哈希值将文件进行排序, 并维持一定的结构(树, 图), 能够一定程度上提高查询的性能, 可以减少副本的数量的同时保障查询的性能

## 2.7 CDN

- 视频的码率压缩

- 多媒体流化服务 : DASH
  - 将一段视频, 切分为一个一个块, 并将每一块并行处理成高码率, 中码率, 低码率等份
  - 给出告示文件, 用于说明某个块的信息 : 码率, URL..
  - 客户端会根据用户的能力和需求, 动态地变化块的码率

- CDN -> 加速服务
  - 数量取胜 enter deep : 将CDN服务器深入到许多的接入网
    - 部署非常多的缓存加速节点服务器, 由租用节点的运营商决定将哪些内容缓存在CSN中, 然后用户发起请求的时候, 会做域名的重定向到最近的CDN服务器
    - 离用户近, 但由于数量多 -> 管理困难
    - Akamai

  - bring home 
    - 部署在少数关键位置, 如将服务器簇安装于POP附近 (离若干$1^{st}$ISP POP附近)
    - 利用租用线路将服务器簇连接起来
    - Limelight

- CDN的流程

  1. 应用提供方提前部署内容到CND节点

  2. 用户从源服务器获取manifest文件(告示文件) -> 用于指示播放流
  3. 用户根据告示文件向提供的URL请求获取IP
  4. icp的权威服务器再返回CDN的权威服务器的域名到本地的DNS服务器, 供其重新解析
  5. 重新解析后, 访问向CDN的权威服务器, 其再返回的根据它判断后, 返回一个离用户较近的IP地址
  6. 用户从那个IP地址获取视频流

## 2.8 TCP套接字编程

- TCP -> 可靠的, 字节流的服务, 面向连接

  - by the stream, 但是保证报文之间的界限

- 运行流程

  1. 服务器首先运行

     - **创建**欢迎socket -> 一个值

     - 和本地端口**捆绑**

     - 在欢迎socket上阻塞式**等待接收**用户的连接 accept()

  2. 客户端主动和服务器建立连接

     - **创建**本地客户端的套接字, 隐式捆绑到本地的port

     - 指定服务器进程的IP端口, 和服务器**连接**

  3. 客户端连接到来的时候
     - **接受**来自用户端的请求, 解除阻塞式的等待, 等待的一个新的socket (connection socket)
  4. 连接API调用有效的时候, 连接的就建立起来了

- 数据结构 sockaddr_in : IP地址和port绑定关系的数据结构

  ```c
  struct sockadrr_in {
      short sin_family; // 地址簇
      u_short sin_port; // port
      u_long sin_addr; // IP地址
      char si n_zero[8]; // 别名
  }
  ```

  数据结构 host_ent : 域名和IP地址相对应的数据结构

  ```c
  struct hostent {
      char *h_name; // 主机的域名
      char ** h_aliases; // 主机的别名
      int h_length; // 地址的长度
      char **h_addr_list; // IP的列表
      int h_addrtype; // 
  }
  ```

  运行流程

  ## 2.9 UDP

  通信过程

​	

