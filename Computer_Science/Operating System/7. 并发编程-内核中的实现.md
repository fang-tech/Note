# 回顾
 
-  在实现互斥的时候
    - 最开始的时候是Petersen协议, 这是种很精妙的协议, 但是这个解决方式其实并不是一个符合直觉的解决方式
    - 最后我们通过自旋锁解决了这个问题, 在硬件上提供了原子指令, 实现原子的读和写, 这样能保证同时只有一个对象能写这块内存(原子指令的作用存疑)
    - 我们其实也可以通过简单的Stop The World 让当前程序独占一个整个计算机, 但是这种实现方式很明显会极大的损失其他的处理器的性能, 所以实际上我们更多为一个Shared memory 创建一个锁, 应用程序通过这个锁实现的互斥
# 操作系统内核中的互斥

## 但是这样实现就没有问题了嘛

- 现在这种实现方式, 可能会存在的bug
    - 上述的实现方式是有一定的问题的, 比如$x_1和x_2$持有了Lock_1, 这个时候$x_3$这个时候访问了这块内存, 就会有Data Race出现
    - 中断机制导致的冲突, 现在我们有一个应用程序, 执行sum++, 在执行之前执行了`lock()` , 但但是在执行sum++的时候发生了中断, 而中断程序, 同样想执行sum++, 并且也会先执行 `sum++` 但是这个时候Lock中的值已经是 X 了, 那么中断程序永远无法正确获取到锁, 无法执行sum++
- 总结 : 操作系统上的并发编程之所以复杂, 就是因为有很多外部的干扰, 这个时候我们需要完备地考虑这些才能让我们的程序正确地执行

## 实现互斥 != 自旋, 还有中断! 该怎么解决呢

- 如果能关闭中断, 并且让锁自旋, 这个时候, 就能保证内核中的互斥
    - 那么中断关闭的时间是`lock()`之前, 还是`lock()`之后呢
    - 如果是之前, 我们上述说的第二种bug是能正确运行的
    - 如果是之后, 那么会陷入之前一样的死锁的情况
- 关闭了中断以后我们肯定还是要恢复中断的, 不然岂不是因为一个程序永远关闭中断了
    - 恢复的时机很明显是在`unlock()`之后
    - 但是这个时候的问题是我们是将中断的状态都设置为什么? 打开状态
- 我们这个时候想做的其实并不是单纯的将中断打开或关闭, 本质上, 我们想做的其实是将`lock()`和`unlock()`之间的代码视作一个原子指令, 可以抽象成一步状态机的迁移, 这个时候我们会发现我们其实是想要这个 '原子指令' 执行前后, 中断的状态是不变的, 所以我们需要做的是在`unlock()`后 **恢复中断状态**
## 实现

创建一个栈, 用于存储中断的状态, 在`lock()`的时候, 将当前的中断状态push进入stack中, 在`unlock()`的时候, 再pop出来, 如果EFLAG == IF, 就设置中断状态为enable

- 通过这个方法我们就解决了中断嵌套会引发的问题, 并且能成功恢复在进入临界区之前的中断状态

# 操作系统内核中的(半)无锁互斥

## 为什么会有这个策略

- 在操作系统内核的层面, 有很多的对象是读写严重不对称的, 我们更多的时候只是读, 而没有写这个操作, 比如, 我们经常校验用户的权限, 但是很少修改用户的密码
- 所以我们就想能否利用这个特性, 实现互斥

## RCU (Read-Copy-Write)

> 简述

不再是读写都针对同一个对象(read and write), 而是先复制一份copy, 再对copy进行write操作

> 前提

- 读写不对称的
- 能接受短时间内, 同一时间, 不同的cpu能读到不同的版本

> 删除原版本的时机和如何实现切换

- 如何实现切换
    - 有一个指针指向当前read的对象
    - 切换就是为这个指针重新赋值

- 删除原文件的时机
    - 直到某一刻, 所有的cpu都退出临界区, 这个时候才会删除就旧数据

> 比喻说明

- 你现在需要给图书馆换灯泡, 你需要尽可能得不影响到大家读书
    - 如果直接将旧灯泡卸下来再装新灯泡, 这个时候就会有空档期, 大家会无法读书
    - 所以合适的做法是, 先装新灯泡, 再将旧灯泡卸下来
    - 等最后一个用旧灯泡的人离开, 再拆灯泡
        - 会观察所有在换灯泡前进入客厅的人都已经离开了

## Scalability

> 这个指标用于衡量系统随处理器增加的运行速率

- 自旋锁在这方面是很糟糕的, 越多的处理器争抢锁, 性能的浪费就越大, 更多的处理器, 更差的性能
    - 大量的cpu在空转 : 只是在争抢锁, 没有干别的事, 造成了很大的资源浪费

# 应用程序中的互斥

## 应用程序使用自旋锁的后果

- 性能问题1 : cpu空转性能浪费
    - 一个线程获取到锁以后, 其他的等待锁的线程就会一直空转等待获取锁
    - 这个时候如果临界区比较长, 就适合在这个时候将cpu交给别的线程去执行
- 性能问题2 : 应用程序不能关中断
    - 持有自旋锁的应用进程会被切换
    - 导致了100%的资源浪费

- 这个时候要是我们能告诉操作系统就好了, 从而将cpu让出去

## 怎么将cpu让出去
### 只有syscal能实现

- 将锁的实现放到操作系统的层面就好了
    - syscal(SYSCAL_LOCK, &lk) 
        - 试图获取锁, 如果没有获取到, 就切换到别的线程, 同时这个线程sleep
    - syscal(SYSCAL_UNLOCK, &lk)
        - 释放lk, 如果有等待锁的线程, 就将线程唤醒

### pthread Mutex Lock

- 一个Scalability足够强的实现

- 使用方法和自旋锁完全一致
```
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);

pthread_mutex_lock(&lock);
pthread_mutex_unlock(&lock);
```






