---
tags:
  - 操作系统
---
# 应用视角的操作系统

## 指令序列

指令的作用是使程序由一个状态转移到另一个状态
指令分为两种 : 计算指令和系统调用指令
- 计算指令绝大多数都是确定的, 也就是如果唯一确定了当前状态和执行的指令, 唯一对应下一个状态, 少部分指令是不确定的, (如rdrand返回的是随机数)
- 系统调用指令是非确定性的, 操作系统可能会将计算机运行环境中的信息输入到程序中, 比如来自设备的输入

## 高级语言的状态机模型

对于操作系统上的程序一个很重要的理解就是, 程序是计算和系统调用组成的状态机

- 状态机由两个部分组成 : M : 内存, R  寄存器, 由这两部分, 我们唯一确定一个状态
- 初始状态 : ABI规定
- 状态迁移 : 执行一条指令

操作系统上的程序只能执行计算指令, 如果想执行系统指令, 就需要将当前状态 (M, R) 完全交给操作系统

## 构建最简单的hello world文件

- 直接使用c语言编译生成的文件非常庞大, 很明显不满足条件, 有133多行代码

- 而其中最大的部分的引入发生在link阶段, 所以我们通过`gcc -c`直接编译生成.o中间文件, 这个文件不包含link后的内容
```
a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <main>:
  401000:       f3 0f 1e fa             endbr64
  401004:       55                      push   %rbp
  401005:       48 89 e5                mov    %rsp,%rbp
  401008:       b8 00 00 00 00          mov    $0x0,%eax
  40100d:       5d                      pop    %rbp
  40100e:       c3                      ret
```

- 接下来人工进行link, 然后运行生成的.out文件
    - 如果在代码里加上一行死循环, 就不会出问题
    - 但是如果没有加的话, 会给出报错, segmentation fault

- 现在的代码是
```c
int main() {}
```

- 通过GDB排错, 给了PC一个异常的值, 程序异常退出
- 有办法让程序在异常退出之前, 主动退出吗 ?
    - 通过计算指令是无法完成退出这一指令的
    - 通过调用系统API实现

- 最终的代码

```S
#include <sys/syscall.h>

.globl _start
_start:
  movq $SYS_write, %rax   // write(
  movq $1,         %rdi   //   fd=1,
  movq $st,        %rsi   //   buf=st,
  movq $(ed - st), %rdx   //   count=ed-st
  syscall                 // );

  movq $SYS_exit,  %rax   // exit(
  movq $1,         %rdi   //   status=1
  syscall                 // );

st:
  .ascii "\033[01;31mHello, OS World\033[0m\n"
ed:
```

- 编译, 链接( 不需要指定程序的入口, 代码中已经指定了) 后, 运行后, 可以生成红色的Hello World


## 应用程序

应用程序 = 计算指令 + 操作系统API 

