# Bug和Debug

## 在调试之前摆正心态

### 公理1 : 机器永远是对的 

- 机器是无情的执行指令的机器, 不会像人类一样犯模糊的错误, 它永远是精确的而正确的

### 公理2 : 未测代码永远是错的

- 反复测试过的代码都是错的
- 你以为最不可能出bug的地方, 往往bug就躺在那里

## 调试理论

### 什么是软件

- 人类需求在信息世界的投影
    - 这其中的bug -> 理解错了需求
-  计算过程的精确数学描述
    - 这是在实现上的数学错误
    - 人类永远是不精确和不可靠的
### 调试理论

- 调试 = 观察程序运行的时候某一个侧面的状态机
- 再通过这个过程, 定位问题的位置
- everything is state machine
### self-check list

1. 是怎么样的程序在运行
2. 我们遇到了怎么样的failure
3. 我们能从状态机的运行中从易到难得到什么信息
4. 如何二分检查这些信息和error之间的关系

# 调试理论 : 应用

## Technical Debt

- 每当你写出不好维护的代码, 你都在给你未来的调试/维护带来麻烦
    - 因为你能确定 "出错概率很小" 的空间被你的技术债压缩, 最后调试面越来越大

## 写一份好的代码

- 写好代码 : 不要在写代码的时候忘记需求和设计
- 不言自明 (Self-explanatory)
    - 能通过字面知道需求 (流程)
- 不言自证 (Self-evident)
    - 能通过字面确认代码和需求一致
- AI 是个很好的辅助者, AI的直觉和规范性很非常好的, 那么其实有个很简单的评判标准
    - AI能看懂的是好的代码


## 测试

- 未测代码永远是错误的
- 残酷的现实 : 相信自己写不对代码

## 断言

- 在代码中在执行某一个步骤之前, 加上对于一些隐形的假设的assert
- 这些断言往往看起来像是废话, 但是 **前提是你的代码时对的**, 这并不显然

# 建议

## 观察者

> 这个事情非常重要, 通过将行为告诉AI, 通过和AI的交流, 演化出来更好的执行方式, 这样的第三者能帮助走出自己舒适圈, 并且AI是个真正意义上(除了语料带来的污染), 最为知识渊博和不偏不倚的第三者

- **我们都需要一个跳出问题看问题的观察者, 告诉我如何做的更好**
- **AI这个工具能很好地帮助演化各个行为**

- 回顾自己刚才做的行为
- 能不能做得更好

## "时间压力" 带来的负面影响

- 总是被迫用肌肉记忆去完成一份代码