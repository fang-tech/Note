# 进程线程基本知识

## 进程

![s](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/4-%E8%BF%9B%E7%A8%8B%E4%BA%A4%E6%9B%BF%E8%BF%90%E8%A1%8C.jpg)

对于这种**多个程序, 交替运行**的想法就是操作系统管理多进程的最初的想法

对于一个支持多进程的操作系统, 它会在多个进程之间频繁切换, 每个进程执一段时间, 以此造成了多个程序**并行**执行的错觉
但是实际上, 这些程序是**并发**执行的

> 并行和并发的区别

![s](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

- 并发是一个处理器让多个任务交替运行, 同时执行多个任务, 是看似并行
- 并行是多个处理器分别处理多个任务, 是真正意义上的并行

### 进程的状态

操作系统会切换任务, 在多个任务之间交替运行, 是一种, **运行-暂停-运行**的工作状态, 那么在我们这个处理器恢复运行进程的时候, 需要恢复这个进程的状态

![进程的状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

- 创建状态 : 进程在创建的时候的状态
- 就绪状态 : 可运行的状态, 只是目前被阻塞了, 处理器正在处理其他的进程, 随时能重新运行当前进程
- 运行状态 : 进程被调度以后, 就会由就绪状态进入到运行状态, 表示进程正在执行
- 结束状态 : 进程运行结束以后, 进程正在从操作系统中消失的时候的状态
- 阻塞状态 : 进程在等待某个外部事件的完成, 比如磁盘IO的时候, 会进入阻塞状态, 直到事件完成, 触发中断, 唤醒程序重新回到就绪状态
- 阻塞挂起状态 : 在虚拟内存管理的操作系统中, 通常会将阻塞状态的进程的物理内存交换到磁盘中, 以减少这些被挂起的进程占用的物理内存
- 就绪挂起状态 : 进程在磁盘中, 但只要进入到内存中, 就会运行, 是在内存中没有足够的空间供当前进程运行的时候, 这个进程就会进入就绪挂起状态

挂起进程的原因

- 用户手动的挂起, 比如Linux中的`Ctrl + z`
- 内存紧张的时候的内存置换, 也就是swap机制, 进程被kswapd守护进程换入到硬盘中, 这个时候这个被换入的进程就会进入到就绪挂起状态
- 内存空间不足以这个进程运行的时候, 这个事件出现的时机有很多种, 比如这个进程被创建以后, 在阻塞挂起状态被唤醒以后, 出现了物理内存空间不足的情况, 都会导致程序进入就绪挂起状态, 等待物理内存有足够的资源的时候再恢复运行

### 进程的控制结构

进程控制结构(Proccess Control Block), 操作系统通过PCB描述一个进程, 也是一个进程存在的唯一标识, 也就是如果一个进程的PCB消失了, 那么这个进程也就消失了, 一个进程存在, 也必然有一个相对应的PCB

> PCB包含什么信息呢?

- CPU相关信息 :
  - CPU中的各个寄存器的值, 在被中断执行的时候, 会保存CPU中的各个寄存器的值, 以便在重新运行的时候, 能重新从断点处重新运行, 可以说CPU相关信息就是进程运行的上下文
- 资源分配清单
  - 打开的文件列表, 使用的I/O设备信息,  有关内存地址和虚拟地址的信息
- 进程描述信息
  - 进程标识符 : 标识进程的唯一ID
  - 用户标识符 : 标识这个进程属于哪个用户, 记录的应该是用户的唯一ID
- 进程控制和管理信息
  - 进程当前的状态 : 如创建, 阻塞, 就绪等
  - 进程优先级 : 进程抢占处理器运行时间的时候的优先级

> 那么PCB是怎么组织的呢?

通过链表的形式将PCB连接起来, 同时根据PCB的不同进程状态, 不同类的PCB链接到不同的链表上
![s](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg)

同时操作系统还会维护一个PCB的索引表, 来提高查找的性能, 使用链表的原因是, 进程的创建和销毁是件很频繁的事件, 而链表的创建和删除性能很好, - 在Linux中构建索引表是通过建立PID->PCB的哈希表

### 进程的控制

结合PCB解释我们能控制进程做什么

创建进程
操作系统允许一个进程创建另一个子进程, 并让子进程继承父进程的所有资源

- 申请一个空白的PCB, 初始化地向里面填入控制和管理管理信息以及进程描述信息
- 为该进程分配必要的资源, 比如内存资源
- 将PCB插入到就绪队列, 等待被CPU调度运行

终止进程
进程被终止方式有三种 : 正常终止, 异常终止, 外界信号干预
如果进程有子进程, 在进程被杀死的时候, 如果子进程还存在的时候, 会将子进程视作孤儿线程, 托孤给1号进程(system), 由1号进程对他们完成状态手机工作

- 查找需要终止的进程的PCB
- 检查进程的状态, 如果进程正在运行, 停止进程的运行
- 如果进程有子进程, 将子进程变成孤儿线程
  - 将子进程托孤给1号进程
- 将进程所拥有的所有资源还给操作系统
- 删除PCB

阻塞进程
当进程需要等待某个事件完成的时候, 可以调用进程阻塞语句, 将自己阻塞, 等待唤醒

- 找到需要阻塞的线程的PCB
- 如果进程是运行状态, 保护现场, 将进程阻塞, 将进程的状态标识为阻塞状态
- 将PCB转移到阻塞队列中

唤醒进程
在进程被阻塞的时候是无法自己唤醒自己的, 需要发现者进程使用唤醒语句将被阻塞的进程唤醒

- 找到被阻塞进程的PCB
- 如果进程是阻塞状态, 将PCB从阻塞队列中移出, 并标记为就绪状态
- 将进程PCB添加到就绪队列, 等待处理器调度

### 进程的上下文切换

> cpu上下文切换

cpu的上下文是告诉cpu该从哪里加载任务, 从哪里开始执行任务的内容

- cpu寄存器
- 程序计数器 - 存储的是cpu要执行的指令

在切换任务的时候, 系统内核会保存cpu上下文, 以便在恢复运行的时候重新加载cpu的上下文, 以继续执行上次的任务

这里的任务主要包括 : 进程, 线程, 中断. 所以对应的cpu的上下文切换也包括进程上下文切换, 线程上下文切换, 中断上下文切换三种

> 进程上下文切换切换的内容

进程的切换只能发生在内核态
进程切换的内容分成内核空间和用户空间

- 用户空间有堆 栈, 全局变量等用户空间的资源
- 内核空间的资源包括内核堆栈, 寄存器等资源

## 线程

