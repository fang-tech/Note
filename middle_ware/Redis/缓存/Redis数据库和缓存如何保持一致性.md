# Redis数据库和缓存如何保证一致性

## 先更新缓存还是先更新数据库

注意, 这里说的不是删除缓存, 而是**更新**缓存, 最后的结论是, 不管是先更新缓存还是先更新数据库, 都会因为并发出现数据库和缓存中数据不一致的情况

### 先更新缓存

![图片](https://img-blog.csdnimg.cn/img_convert/454a8228a6549176ad7e0484fba3c92b.png)

### 先更新数据库

![图片](https://img-blog.csdnimg.cn/img_convert/8febac10b14bed16cb96d1d944cd08da.png)

## 先更新数据库还是先删除缓存

这里的内容在 [](../redis面试题.md)中的常见缓存更新策略中能看到

这里是想说下在旁路缓存的方式中, 过期时间的用处

通过设置过期时间, 能保证在更新一定时间以后, 一定能保证缓存数据和数据库数据的一致性, 因为可能删除缓存这个操作会出现错误

## 补充 (一些保护手段)

**如果业务对缓存的命中率有一定的要求, 这个时候先更新数据库再更新缓存的策略其实是更好的选择**, 那么如何在这样的策略下保证数据的一致性呢

- 在更新缓存前加上一个分布式锁 : 将[**更新数据库 + 更新缓存**]从线程的角度来看视作一个**互斥**操作, 这样就能保证数据库和缓存中的数据的一致性
- 在更新完缓存以后, 为缓存加上一个较短的**过期时间**, 这样能兜底保证业务中的数据一致性

## 如何保证两个操作都能执行成功

不论是先删除缓存 + 更新数据库还是先更新数据库 + 删除缓存都会因为第二个操作失败而导致数据不一致

- 重试机制
- 订阅MySQL binlog, 再操作缓存

### 重试机制

引入**消息队列**, 将需要操作数据加入到消息队列中

- 如果用户删除缓存操作**失败**, 就从**消息队列中重新读取数据**, 然后重新执行删除操作. 删除失败重试, 如果到达一定次数, 向业务层发送报错信息, 这就是**重试机制**
- 如果**删除成功**就将消息队列中的信息删除

### 订阅MySQL binlog, 再操作缓存

更新数据库成功以后, 会产生一条变更日志, 记录在binlog里面, 可以通过订阅binlog日志拿到具体要操作的数据, 再执行缓存删除. Canal中间件就是基于这个实现的

![图片](https://img-blog.csdnimg.cn/img_convert/2ee2280e9f59b6b4879ebdec6eb0cf52.png)